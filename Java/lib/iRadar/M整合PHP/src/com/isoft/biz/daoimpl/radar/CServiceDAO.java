package com.isoft.biz.daoimpl.radar;

import static com.isoft.iradar.Cphp._;
import static com.isoft.iradar.Cphp._s;
import static com.isoft.iradar.Cphp.array_merge;
import static com.isoft.iradar.Cphp.array_unique;
import static com.isoft.iradar.Cphp.empty;
import static com.isoft.iradar.Cphp.implode;
import static com.isoft.iradar.Cphp.in_array;
import static com.isoft.iradar.Cphp.is_null;
import static com.isoft.iradar.Cphp.is_numeric;
import static com.isoft.iradar.Cphp.isset;
import static com.isoft.iradar.Cphp.ksort;
import static com.isoft.iradar.Cphp.reset;
import static com.isoft.iradar.Cphp.unset;
import static com.isoft.iradar.inc.DBUtil.DBfetch;
import static com.isoft.iradar.inc.DBUtil.DBselect;
import static com.isoft.iradar.inc.DBUtil.idcmp;
import static com.isoft.iradar.inc.Defines.API_OUTPUT_COUNT;
import static com.isoft.iradar.inc.Defines.API_OUTPUT_EXTEND;
import static com.isoft.iradar.inc.Defines.PERM_DENY;
import static com.isoft.iradar.inc.Defines.RDA_API_ERROR_PARAMETERS;
import static com.isoft.iradar.inc.Defines.RDA_API_ERROR_PERMISSIONS;
import static com.isoft.iradar.inc.Defines.SEC_PER_DAY;
import static com.isoft.iradar.inc.Defines.SEC_PER_HOUR;
import static com.isoft.iradar.inc.Defines.SEC_PER_MIN;
import static com.isoft.iradar.inc.Defines.SEC_PER_WEEK;
import static com.isoft.iradar.inc.Defines.SERVICE_ALGORITHM_NONE;
import static com.isoft.iradar.inc.Defines.SERVICE_SHOW_SLA_OFF;
import static com.isoft.iradar.inc.Defines.SERVICE_SHOW_SLA_ON;
import static com.isoft.iradar.inc.Defines.SERVICE_TIME_TYPE_DOWNTIME;
import static com.isoft.iradar.inc.Defines.SERVICE_TIME_TYPE_ONETIME_DOWNTIME;
import static com.isoft.iradar.inc.Defines.SERVICE_TIME_TYPE_UPTIME;
import static com.isoft.iradar.inc.Defines.USER_TYPE_SUPER_ADMIN;
import static com.isoft.iradar.inc.FuncsUtil.rda_array_merge;
import static com.isoft.iradar.inc.FuncsUtil.rda_cleanHashes;
import static com.isoft.iradar.inc.FuncsUtil.rda_empty;
import static com.isoft.iradar.inc.FuncsUtil.rda_is_int;
import static com.isoft.iradar.inc.FuncsUtil.rda_objectValues;
import static com.isoft.iradar.inc.FuncsUtil.rda_toArray;
import static com.isoft.iradar.inc.FuncsUtil.rda_toHash;
import static com.isoft.iradar.inc.PermUtil.getUserGroupsByUserId;
import static com.isoft.iradar.inc.ServicesUtil.checkServiceTime;
import static com.isoft.iradar.inc.ServicesUtil.serviceAlgorythm;
import static com.isoft.iradar.inc.ServicesUtil.updateItServices;
import static com.isoft.types.CArray.array;
import static com.isoft.types.CArray.map;

import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import com.isoft.framework.common.interfaces.IIdentityBean;
import com.isoft.framework.persistlayer.SQLExecutor;
import com.isoft.iradar.api.API;
import com.isoft.iradar.exception.APIException;
import com.isoft.iradar.model.CRelationMap;
import com.isoft.iradar.model.CWebUser;
import com.isoft.iradar.model.params.CParamGet;
import com.isoft.iradar.model.params.CServiceGet;
import com.isoft.iradar.model.params.CSlaGet;
import com.isoft.iradar.model.params.CTriggerGet;
import com.isoft.iradar.model.sql.SqlBuilder;
import com.isoft.iradar.model.sql.SqlDecorator;
import com.isoft.lang.Clone;
import com.isoft.lang.CodeConfirmed;
import com.isoft.types.CArray;
import com.isoft.types.Mapper.Nest;
import com.isoft.types.Mapper.TArray;

@CodeConfirmed("benne.2.2.6")
public class CServiceDAO extends CCoreLongKeyDAO<CServiceGet> {

	public CServiceDAO(IIdentityBean idBean, SQLExecutor executor) {
		super(idBean, executor, "services", "s", new String[]{"sortorder","name"});
	}

	/**
	 * Get services.
	 *
	 * Allowed options:
	 * - parentids                      - fetch the services that are hardlinked to the given parent services;
	 * - childids                       - fetch the services that are hardlinked to the given child services;
	 * - countOutput                    - return the number of the results as an integer;
	 * - selectParent                   - include the parent service in the result;
	 * - selectDependencies             - include service child dependencies in the result;
	 * - selectParentDependencies       - include service parent dependencies in the result;
	 * - selectTimes                    - include service times in the result;
	 * - selectAlarms                   - include alarms generated by the service;
	 * - selectTrigger                  - include the linked trigger;
	 * - sortfield                      - name of columns to sort by;
	 * - sortorder                      - sort order.
	 *
	 * @param array options
	 *
	 * @return array
	 */
	@Override
	public <T> T get(CServiceGet params) {
		// build and execute query
		SqlBuilder sqlParts = createSelectQuery(tableName(), params);
		
		// limit
		if (params.getLimit() != null) {
			sqlParts.limit = params.getLimit();
		}
		CArray<Map> datas = DBselect(getSqlExecutor(), sqlParts);
		
		CArray<Map> result = new CArray<Map>();
		Object ret = result;
		
		for(Map row : datas){
			// a count query, return a single result
			if (params.getCountOutput() != null) {
				ret = row.get("rowscount");
			} else {// a normal select query
				Long id = (Long) row.get(this.pk);
				if (!isset(result.get(id))) {
					result.put(id, new HashMap());
				}
				result.get(id).putAll(row);
			}
		}
		
		if (!is_null(params.getCountOutput())) {
			return (T)ret;
		}
		
		if (!empty(result)) {
			this.addRelatedObjects(params, result);
			this.unsetExtraFields(result, new String[]{"triggerid"}, params.getOutput());
		}
		
		if (is_null(params.getPreserveKeys())) {
			result = rda_cleanHashes(result);
		}
		return (T)result;
	}
	
	/**
	 * Validates the input parameters for the create() method.
	 *
	 * @throws APIException if the input is invalid
	 *
	 * @param array services
	 *
	 * @return void
	 */
	protected void validateCreate(CArray<Map> services) {
		for(Map service : services) {
			checkName(service);
			checkAlgorithm(service);
			checkShowSla(service);
			checkGoodSla(service);
			checkSortOrder(service);
			checkTriggerId(service);
			checkStatus(service);
			checkParentId(service);

			String error = _s("Wrong fields for service \"%1$s\".", Nest.value(service,"name").$());
			checkUnsupportedFields(tableName(), service, error, array(
				"parentid", "dependencies", "times"
			));
		}

		checkTriggerPermissions(services);
	}
	
	/**
	 * Creates the given services.
	 *
	 * @param array services
	 *
	 * @return array
	 */
	@Override
	public CArray<Long[]> create(CArray<Map> services) {
		validateCreate(services);

		// save the services
		CArray<Long> serviceIds = insert(tableName(), Clone.deepcopy(services));

		CArray<Map> dependencies = array();
		CArray<Map> serviceTimes = array();
		for (Entry<Object, Map> e : services.entrySet()) {
		    Object key = e.getKey();
		    Map service = e.getValue();
			Long serviceId = Nest.value(serviceIds,key).asLong();

			// save dependencies
			if (!empty(Nest.value(service,"dependencies").$())) {
				for(Map dependency : (CArray<Map>)Nest.value(service,"dependencies").asCArray()) {
					Nest.value(dependency,"serviceid").$(serviceId);
					dependencies.add(dependency);
				}
			}

			// save parent service
			if (!empty(Nest.value(service,"parentid").$())) {
				dependencies.add(map(
					"serviceid" , Nest.value(service,"parentid").$(),
					"dependsOnServiceid", serviceId,
					"soft", 0
				));
			}

			// save service times
			if (isset(service,"times")) {
				for(Map serviceTime : (CArray<Map>)Nest.value(service,"times").asCArray()) {
					Nest.value(serviceTime,"serviceid").$(serviceId);
					serviceTimes.add(serviceTime);
				}
			}
		}

		if (!empty(dependencies)) {
			addDependencies(dependencies);
		}

		if (!empty(serviceTimes)) {
			addTimes(serviceTimes);
		}

		updateItServices(this.idBean, getSqlExecutor());

		return map("serviceids", serviceIds);
	}

	/**
	 * Validates the input parameters for the update() method.
	 *
	 * @throws APIException if the input is invalid
	 *
	 * @param array services
	 *
	 * @return void
	 */
	public void validateUpdate(CArray<Map> services) {
		for(Map service : services) {
			if (empty(Nest.value(service,"serviceid").$())) {
				throw CDB.exception(RDA_API_ERROR_PARAMETERS, _("Invalid method parameters."));
			}
		}

		checkServicePermissions(rda_objectValues(services, "serviceid").valuesAsLong());

		services = extendObjects(tableName(), services, new String[]{"name"});
		for(Map service : services) {
			checkName(service);

			if (isset(service,"algorithm")) {
				checkAlgorithm(service);
			}
			if (isset(service,"showsla")) {
				checkShowSla(service);
			}
			if (isset(service,"goodsla")) {
				checkGoodSla(service);
			}
			if (isset(service,"sortorder")) {
				checkSortOrder(service);
			}
			if (isset(service,"triggerid")) {
				checkTriggerId(service);
			}
			if (isset(service,"status")) {
				checkStatus(service);
			}
			if (isset(service,"parentid")) {
				checkParentId(service);
			}

			String error = _s("Wrong fields for service \"%1$s\".", Nest.value(service,"name").$());
			checkUnsupportedFields(tableName(), service, error, array(
				"parentid", "dependencies", "times"
			));
		}

		checkTriggerPermissions(services);
	}
	
	/**
	 * Updates the given services.
	 *
	 * @param array services
	 *
	 * @return array
	 */
	@Override
	public CArray<Long[]> update(CArray<Map> services) {
		validateUpdate(services);

		// save the services
		for(Map service : services) {
			updateByPk(tableName(), Nest.value(service,"serviceid").$(), Clone.deepcopy(service));
		}

		// update dependencies
		CArray<Map> dependencies = array();
		CArray<Map> parentDependencies = array();
		CArray<Map> serviceTimes = array();
		CArray deleteParentsForServiceIds = array();
		CArray deleteDependenciesForServiceIds = array();		
		CArray deleteTimesForServiceIds = array();
		for(Map service : services) {
			if (isset(service,"dependencies")) {
				deleteDependenciesForServiceIds.add(Nest.value(service,"serviceid").$());
				if (!empty(Nest.value(service,"dependencies").$())) {
					for(Map dependency : (CArray<Map>)Nest.value(service,"dependencies").asCArray()) {
						Nest.value(dependency,"serviceid").$(Nest.value(service,"serviceid").$());
						dependencies.add(dependency);
					}
				}
			}

			// update parent
			if (isset(service,"parentid")) {
				deleteParentsForServiceIds.add(Nest.value(service,"serviceid").$());
				if (!empty(Nest.value(service,"parentid").$())) {
					parentDependencies.add(map(
						"serviceid", Nest.value(service,"parentid").$(),
						"dependsOnServiceid", Nest.value(service,"serviceid").$(),
						"soft", 0
					));
				}
			}

			// save service times
			if (isset(service,"times")) {
				deleteTimesForServiceIds.add(Nest.value(service,"serviceid").$());
				for(Map serviceTime : (CArray<Map>)Nest.value(service,"times").asCArray()) {
					Nest.value(serviceTime,"serviceid").$(Nest.value(service,"serviceid").$());
					serviceTimes.add(serviceTime);
				}
			}
		}

		// replace dependencies
		if (!empty(deleteParentsForServiceIds)) {
			deleteParentDependencies(rda_objectValues(services, "serviceid").valuesAsString());
		}
		if (!empty(deleteDependenciesForServiceIds)) {
			deleteDependencies(array_unique(deleteDependenciesForServiceIds));
		}
		if (!empty(parentDependencies) || !empty(dependencies)) {
			addDependencies(array_merge(parentDependencies, dependencies));
		}

		// replace service times
		if (!empty(deleteTimesForServiceIds)) {
			deleteTimes(deleteTimesForServiceIds);
		}
		if (!empty(serviceTimes)) {
			addTimes(serviceTimes);
		}

		updateItServices(this.idBean, getSqlExecutor());

		return map("serviceids", rda_objectValues(services, "serviceid").valuesAsLong());
	}

	/**
	 * Validates the input parameters for the delete() method.
	 *
	 * @throws APIException if the input is invalid
	 *
	 * @param array serviceIds
	 *
	 * @return void
	 */
	public void validateDelete(Long[] serviceIds) {
		if (empty(serviceIds)) {
			throw CDB.exception(RDA_API_ERROR_PARAMETERS, _("Empty input parameter."));
		}

		checkServicePermissions(serviceIds);
		checkThatServicesDontHaveChildren(serviceIds);
	}
	
	/**
	 * Delete services.
	 *
	 * @param serviceIds
	 *
	 * @return array
	 */
	@Override
	public CArray<Long[]> delete(Long... serviceIds) {
		validateDelete(TArray.as(serviceIds).asLong());

		delete(tableName(), (CArray)map("serviceid", serviceIds));

		updateItServices(this.idBean, getSqlExecutor());

		return map("serviceids", serviceIds);
	}

	/**
	 * Validates the input parameters for the addDependencies() method.
	 *
	 * @throws APIException if the input is invalid
	 *
	 * @param array dependencies
	 *
	 * @return void
	 */
	protected void validateAddDependencies(CArray<Map> dependencies) {
		if (empty(dependencies)) {
			throw CDB.exception(RDA_API_ERROR_PARAMETERS, _("Empty input parameter."));
		}

		for(Map dependency : dependencies) {
			if (empty(Nest.value(dependency,"serviceid").$()) || empty(Nest.value(dependency,"dependsOnServiceid").$())) {
				throw CDB.exception(RDA_API_ERROR_PARAMETERS, _("Invalid method parameters."));
			}
		}

		CArray serviceIds = array_merge(
			rda_objectValues(dependencies, "serviceid"),
			rda_objectValues(dependencies, "dependsOnServiceid")
		);
		serviceIds = array_unique(serviceIds);
		checkServicePermissions(serviceIds.valuesAsLong());

		for(Map dependency:dependencies) {
			checkDependency(dependency);

			checkUnsupportedFields("services_links", dependency,
				_s("Wrong fields for dependency for service \"%1$s\".", Nest.value(dependency,"serviceid").$()),
				array("dependsOnServiceid", "serviceid")
			);
		}

		checkForHardlinkedDependencies(dependencies);
		checkThatParentsDontHaveTriggers(dependencies);
		checkForCircularityInDependencies(dependencies);
	}
	
	/**
	 * Add the given service dependencies.
	 *
	 * @param array dependencies   an array of service dependencies, each pair in the form of
	 *                              array("serviceid" => 1, "dependsOnServiceid" => 2, "soft" => 0)
	 *
	 * @return array
	 */
	public CArray<Long[]> addDependencies(CArray<Map> dependencies) {
		validateAddDependencies(dependencies);

		CArray<Map> data = array();
		for(Map dependency : dependencies) {
			data.add(map(
				"serviceupid", Nest.value(dependency,"serviceid").$(),
				"servicedownid", Nest.value(dependency,"dependsOnServiceid").$(),
				"soft", Nest.value(dependency,"soft").$()
			));
		}
		insert("services_links", data);

		return map("serviceids", rda_objectValues(dependencies, "serviceid").valuesAsLong());
	}
	
	/**
	 * Validates the input for the deleteDependencies() method.
	 *
	 * @throws APIException if the given input is invalid
	 *
	 * @param array serviceIds
	 *
	 * @return void
	 */
	protected void validateDeleteDependencies(CArray serviceIds) {
		if (empty(serviceIds)) {
			throw CDB.exception(RDA_API_ERROR_PARAMETERS, _("Empty input parameter."));
		}

		checkServicePermissions(serviceIds.valuesAsLong());
	}
	
	/**
	 * Deletes all dependencies for the given services.
	 *
	 * @param array serviceIds
	 *
	 * @return boolean
	 */
	public CArray<Long[]> deleteDependencies(CArray serviceIds) {
		validateDeleteDependencies(serviceIds);

		delete("services_links", (CArray)map(
			"serviceupid",  serviceIds.valuesAsLong()
		));

		return map("serviceids", serviceIds.valuesAsLong());
	}
	
	/**
	 * Validates the input for the addTimes() method.
	 *
	 * @throws APIException if the given input is invalid
	 *
	 * @param array serviceTimes
	 *
	 * @return void
	 */
	public void validateAddTimes(CArray<Map> serviceTimes) {
		for(Map serviceTime : serviceTimes) {
			checkTime(serviceTime);

			checkUnsupportedFields("services_times", serviceTime,
				_s("Wrong fields for time for service \"%1$s\".", Nest.value(serviceTime,"serviceid").$())
			);
		}

		checkServicePermissions(array_unique(rda_objectValues(serviceTimes, "serviceid")).valuesAsLong());
	}
	
	/**
	 * Adds the given service times.
	 *
	 * @param array serviceTimes an array of service times
	 *
	 * @return array
	 */
	public CArray<Long[]> addTimes(CArray<Map> serviceTimes) {
		validateAddTimes(serviceTimes);

		insert("services_times", serviceTimes);

		return map("serviceids", rda_objectValues(serviceTimes, "serviceid").valuesAsLong());
	}
	
	/**
	 * Validates the input for the deleteTimes() method.
	 *
	 * @throws APIException if the given input is invalid
	 *
	 * @param array serviceIds
	 *
	 * @return void
	 */
	protected void validateDeleteTimes(CArray serviceIds) {
		if (empty(serviceIds)) {
			throw CDB.exception(RDA_API_ERROR_PARAMETERS, _("Empty input parameter."));
		}

		checkServicePermissions(serviceIds.valuesAsLong());
	}
	
	/**
	 * Returns availability-related information about the given services during the given time intervals.
	 *
	 * Available options:
	 *  - serviceids    - a single service ID or an array of service IDs;
	 *  - intervals     - a single time interval or an array of time intervals, each containing:
	 *      - from          - the beginning of the interval, timestamp;
	 *      - to            - the end of the interval, timestamp.
	 *
	 * Returns the following availability information for each service:
	 *  - status            - the current status of the service;
	 *  - problems          - an array of triggers that are currently in problem state and belong to the given service
	 *                        or it's descendants;
	 *  - sla               - an array of requested intervals with SLA information:
	 *      - from              - the beginning of the interval;
	 *      - to                - the end of the interval;
	 *      - okTime            - the time the service was in OK state, in seconds;
	 *      - problemTime       - the time the service was in problem state, in seconds;
	 *      - downtimeTime      - the time the service was down, in seconds.
	 *
	 * If the service calculation algorithm is set to SERVICE_ALGORITHM_NONE, the method will return an empty 'problems'
	 * array and null for all of the calculated values.
	 *
	 * @param array options
	 *
	 * @return array    as array(serviceId2 => data1, serviceId2 => data2, ...)
	 */
	public CArray<Map> getSla(CSlaGet params){
		Long[] serviceIds = params.getServiceIds();
		CArray<Map> intervals = params.getIntervals();
		
		CServiceGet svrGet = new CServiceGet();
		svrGet.setOutput(new String[]{"serviceid", "name", "status", "algorithm"});
		svrGet.setSelectTimes(API_OUTPUT_EXTEND);
		svrGet.setSelectParentDependencies(new String[]{"serviceupid"});
		svrGet.setServiceIds(serviceIds);
		svrGet.setPreserveKeys(true);
		
		// fetch services
		CArray<Map> services = get(svrGet);
		
		CArray<Map> rs = array();
		if (services != null && !services.isEmpty()) {
			CArray usedSeviceIds = array();
			CArray problemServiceIds = array();
			
			for (Map service : services) {
				Nest.value(service,"alarms").$(array());
				// don't calculate SLA for services with disabled status calculation
				if (isStatusEnabled(service)) {
					Object serviceid = Nest.value(service,"serviceid").$();
					usedSeviceIds.put(serviceid, serviceid);
					
					if (Nest.value(service,"status").asInteger() > 0) {
						problemServiceIds.add(serviceid);
					}
				}
			}
			
			for (Map service : services) {
				Object serviceid = Nest.value(service,"serviceid").$();
				Nest.value(rs,serviceid).$(map(
					"status", (isStatusEnabled(service)) ? Nest.value(service,"status").$() : null,
					"problems", array(),
					"sla", array()
				));
			}
			
			if (!usedSeviceIds.isEmpty()) {
				// add service alarms
				CArray intervalConditions = array();
				SqlBuilder sqlParts = new SqlBuilder();
				sqlParts.select.put("*");
				sqlParts.from.put("service_alarms sa");
				sqlParts.where.dbConditionInt("sa.serviceid", usedSeviceIds.valuesAsLong());
				
				for (Map interval : intervals) {
					intervalConditions.add("sa.clock BETWEEN "+sqlParts.marshalParam(interval.get("from"))+" AND "+sqlParts.marshalParam(interval.get("to")));
				}
				
				sqlParts.where.put(implode(" OR ", intervalConditions));
				sqlParts.order.put("sa.clock");
				sqlParts.order.put("sa.servicealarmid");
				
				CArray<Map> datas = DBselect(getSqlExecutor(), sqlParts);
				if (datas != null && !datas.isEmpty()) {
					for (Map data : datas) {
						Nest.value(services, data.get("serviceid"), "alarms").push(data);
					}
				}
				
				// add problem triggers
				if (!problemServiceIds.isEmpty()) {
					CArray<CArray<Map>> problemTriggers = fetchProblemTriggers(problemServiceIds.valuesAsLong());
					rs = escalateProblems(services, problemTriggers, rs);
				}
				
				for (Map interval : intervals) {
					CArray<Integer> latestValues = fetchLatestValues(usedSeviceIds.valuesAsLong(), Nest.value(interval,"from").asInteger());
					
					for (Map service : services) {
						Object serviceId = Nest.value(service,"serviceid").$();

						// only calculate the sla for services which require it
						CArray intervalSla = null;
						if (isset(usedSeviceIds.get(serviceId))) {
							int latestValue = (isset(latestValues.get(serviceId))) ? latestValues.get(serviceId) : 0;
							intervalSla = calculateSla(service, Nest.value(interval,"from").asInteger(), Nest.value(interval,"to").asInteger(), latestValue);
						} else {
							intervalSla = map(
								"ok", null,
								"okTime", null,
								"problemTime", null,
								"downtimeTime", null
							);
						}

						Nest.value(rs,serviceId,"sla").push(map(
							"from", Nest.value(interval,"from").$(),
							"to", Nest.value(interval,"to").$(),
							"sla", Nest.value(intervalSla,"ok").$(),
							"okTime", Nest.value(intervalSla,"okTime").$(),
							"problemTime", Nest.value(intervalSla,"problemTime").$(),
							"downtimeTime", Nest.value(intervalSla,"downtimeTime").$()
						));
					}
				}
			}
		}
		return rs;
	}
	
	/**
	 * Deletes all service times for the given services.
	 *
	 * @param array serviceIds
	 *
	 * @return boolean
	 */
	public CArray<Long[]> deleteTimes(CArray serviceIds) {
		serviceIds = rda_toArray(serviceIds);
		validateDeleteTimes(serviceIds);

		delete("services_times", (CArray)map(
			"serviceid",  serviceIds.valuesAsLong()
		));

		return map("serviceids", serviceIds.valuesAsLong());
	}
	
	/**
	 * Returns true if all of the given objects are available for reading.
	 *
	 * @param ids
	 *
	 * @return bool
	 */
	@Override
	public boolean isReadable(Long... ids) {
		if (empty(ids)) {
			return true;
		}
		ids = array_unique(CArray.valueOf(ids)).valuesAsLong();
		
		CServiceGet params = new CServiceGet();
		params.setServiceIds(ids);
		params.setCountOutput(true);
		long count = get(params);
		return ids.length == count;
	}

	/**
	 * Returns true if all of the given objects are available for writing.
	 *
	 * @param ids
	 *
	 * @return bool
	 */
	@Override
	public boolean isWritable(Long... ids) {
		return this.isReadable(ids);
	}
	
	/**
	 * Deletes the dependencies of the parent services on the given services.
	 *
	 * @param serviceIds
	 *
	 * @return void
	 */
	protected void deleteParentDependencies(String[] serviceIds) {
		delete("services_links", (CArray)map(
			"servicedownid", serviceIds,
			"soft", 0
		));
	}

	/**
	 * Calculates the SLA for the given service during the given period.
	 *
	 * Returns the following information:
	 * - ok             - the percentage of time the service was in OK state;
	 * - problem        - the percentage of time the service was in problem state;
	 * - okTime         - the time the service was in OK state, in seconds;
	 * - problemTime    - the time the service was in problem state, in seconds;
	 * - downtimeTime   - the time the service was down, in seconds;
	 * - dt;
	 * - ut.
	 *
	 * @param array service
	 * @param periodStart
	 * @param periodEnd
	 * @param prevAlarm        the value of the last service alarm
	 *
	 * @return array
	 */
	protected CArray calculateSla(Map service, long periodStart, long periodEnd, long prevAlarm) {
		/**
		 * structure of \"_data\":
		 * - key	- time stamp
		 * - alarm	- on/off status (0,1 - off; >1 - on)
		 * - dt_s	- count of downtime starts
		 * - dt_e	- count of downtime ends
		 * - ut_s	- count of uptime starts
		 * - ut_e	- count of uptime ends
		 */
		CArray<Map> data = array();
		
		CArray<Map> alarms = Nest.value(service,"alarms").asCArray();
		for (Map alarm : alarms) {
			if (Nest.value(alarm,"clock").asInteger() >= periodStart && Nest.value(alarm,"clock").asInteger() <= periodEnd) {
				Nest.value(data,alarm.get("clock"),"alarm").$(Nest.value(alarm,"value").$());
			}
		}
		
		String unmarkedPeriodType = "ut";
		
		CArray<Map> times = Nest.value(service,"times").asCArray();
		for (Map time : times) {
			int type = Nest.value(time,"type").asInteger();
			if (type == SERVICE_TIME_TYPE_UPTIME) {
				expandPeriodicalTimes(data, periodStart, periodEnd, Nest.value(time,"ts_from").asLong(), Nest.value(time,"ts_to").asLong(), "ut");
	
				// if an uptime period exists - unmarked time is downtime
				unmarkedPeriodType = "dt";
			} else if (type == SERVICE_TIME_TYPE_DOWNTIME) {
				expandPeriodicalTimes(data, periodStart, periodEnd, Nest.value(time,"ts_from").asLong(), Nest.value(time,"ts_to").asLong(), "dt");
			} else if(type == SERVICE_TIME_TYPE_ONETIME_DOWNTIME && Nest.value(time,"ts_to").asLong() >= periodStart && Nest.value(time,"ts_from").asLong() <= periodEnd) {
				if (Nest.value(time,"ts_from").asLong() < periodStart) {
					Nest.value(time,"ts_from").$(periodStart);
				}
				if (Nest.value(time,"ts_to").asLong() > periodEnd) {
					Nest.value(time,"ts_to").$(periodEnd);
				}
	
				long ts_from = Nest.value(time,"ts_from").asLong();
				if (isset(Nest.value(data,ts_from,"dt_s").$())) {
					Nest.value(data,ts_from,"dt_s").$(Nest.value(data,ts_from,"dt_s").asLong()+1);
				} else {
					Nest.value(data, ts_from, "dt_s").$(1L);
				}
	
				long ts_to = Nest.value(time,"ts_to").asLong();
				if (isset(Nest.value(data,ts_to,"dt_e").$())) {
					Nest.value(data,ts_to,"dt_e").$(Nest.value(data,ts_to,"dt_e").asLong()+1);
				} else {
					Nest.value(data, ts_to, "dt_e").$(1L);
				}
			}
		}
		
		if (!isset(data.get(periodEnd))) {
			data.put(periodEnd, array());
		}
		
		// sort by time stamp
		ksort(data);
	
		// calculate times
		long dtCnt = 0;
		long utCnt = 0;
		CArray slaTime = map(
			"dt", map("problemTime", 0f, "okTime", 0f),
			"ut", map("problemTime", 0f, "okTime", 0f)
		);
		long prevTime = periodStart;
	
		if (isset(Nest.value(data,periodStart,"ut_s").$())) {
			utCnt += Nest.value(data,periodStart,"ut_s").asLong();
		}
		if (isset(Nest.value(data,periodStart,"ut_e").$())) {
			utCnt -= Nest.value(data,periodStart,"ut_e").asLong();
		}
		if (isset(Nest.value(data,periodStart,"dt_s").$())) {
			dtCnt += Nest.value(data,periodStart,"dt_s").asLong();
		}
		if (isset(Nest.value(data,periodStart,"dt_e").$())) {
			dtCnt -= Nest.value(data,periodStart,"dt_e").asLong();
		}
		
	    for (Entry<Object, Map> e : data.entrySet()) {
	        long ts = Nest.as(e.getKey()).asLong();
	        Map val = e.getValue();
			// skip first data [already read]
			if (ts == periodStart) {
				continue;
			}
	
			String periodType = null;
			if (dtCnt > 0) {
				periodType  = "dt";
			} else if (utCnt > 0) {
				periodType = "ut";
			} else {
				periodType = unmarkedPeriodType;
			}
	
			// state=0,1 [OK] (1 - information severity of trigger), >1 [PROBLEMS] (trigger severity)
			if (prevAlarm > 1) {
				Nest.value(slaTime, periodType,"problemTime").$(Nest.value(slaTime, periodType,"problemTime").asFloat() + ts - prevTime);
			} else {
				Nest.value(slaTime, periodType,"okTime").$(Nest.value(slaTime, periodType,"okTime").asFloat() + ts - prevTime);
			}
	
			if (isset(Nest.value(val,"ut_s").$())) {
				utCnt += Nest.value(val,"ut_s").asLong();
			}
			if (isset(Nest.value(val,"ut_e").$())) {
				utCnt -= Nest.value(val,"ut_e").asLong();
			}
			if (isset(Nest.value(val,"dt_s").$())) {
				dtCnt += Nest.value(val,"dt_s").asLong();
			}
			if (isset(Nest.value(val,"dt_e").$())) {
				dtCnt -= Nest.value(val,"dt_e").asLong();
			}
			if (isset(Nest.value(val,"alarm").$())) {
				prevAlarm = Nest.value(val,"alarm").asLong();
			}
	
			prevTime = ts;
		}
	
		Nest.value(slaTime,"problemTime").$(Nest.value(slaTime,"ut","problemTime").$());
		Nest.value(slaTime,"okTime").$(Nest.value(slaTime,"ut","okTime").$());
		Nest.value(slaTime,"downtimeTime").$(Nest.value(slaTime,"dt","okTime").asFloat() + Nest.value(slaTime,"dt","problemTime").asFloat());
	
		float fullTime = Nest.value(slaTime,"problemTime").asFloat() + Nest.value(slaTime,"okTime").asFloat();
		if (fullTime > 0f) {
			Nest.value(slaTime,"problem").$(100f * Nest.value(slaTime,"problemTime").asFloat() / fullTime);
			Nest.value(slaTime,"ok").$(100f * Nest.value(slaTime,"okTime").asFloat() / fullTime);
		} else {
			Nest.value(slaTime,"problem").$(100f);
			Nest.value(slaTime,"ok").$(100f);
		}
	
		return slaTime;
	}

	/**
	 * @see calculateSla()
	 *
	 * @param data
	 * @param period_start
	 * @param period_end
	 * @param ts_from
	 * @param ts_to
	 * @param type
	 *
	 * @return void
	 */
	@SuppressWarnings("deprecation")
	private void expandPeriodicalTimes(CArray data, long period_start, long period_end, long ts_from, long ts_to, String type) {
		Date date = new Date(period_start * 1000);
		long week = period_start - date.getDay() * SEC_PER_DAY - date.getHours() * SEC_PER_HOUR - date.getMinutes() * SEC_PER_MIN - date.getSeconds();
		for (; week < period_end; week += SEC_PER_WEEK) {
			long _s = week + ts_from;
			long _e = week + ts_to;

			if (period_end < _s || period_start >= _e) {
				continue;
			}

			if (_s < period_start) {
				_s = period_start;
			}
			if (_e > period_end) {
				_e = period_end;
			}

			if (isset(Nest.value(data,_s,type+"_s").$())) {
				Nest.value(data,_s,type+"_s").$(Nest.value(data,_s,type+"_s").asLong()+1);
			} else {
				Nest.value(data,_s,type+"_s").$(1L);
			}

			if (isset(Nest.value(data,_e,type+"_e").$())) {
				Nest.value(data,_e,type+"_e").$(Nest.value(data,_e,type+"_e").asLong()+1);
			} else {
				Nest.value(data,_e,type+"_e").$(1L);
			}
		}
	}

	/**
	 * Returns an array of triggers which are in a problem state and are linked to the given services.
	 *
	 * @param array serviceIds
	 *
	 * @return array    in the form of array(serviceId1 => array(triggerId => trigger), ...)
	 */
	protected CArray<CArray<Map>> fetchProblemTriggers(Long[] serviceIds){
		SqlBuilder sqlParts = new SqlBuilder();
		sqlParts.select.put("s.serviceid");
		sqlParts.select.put("t.triggerid");
		sqlParts.from.put("services s");
		sqlParts.from.put("triggers t");
		sqlParts.where.put("s.status>0");
		sqlParts.where.put("t.tenantid=s.tenantid");
		sqlParts.where.put("t.triggerid=s.triggerid");
		sqlParts.where.dbConditionInt("s.serviceid", serviceIds);
		sqlParts.order.put("s.status DESC");
		sqlParts.order.put("t.description");
		
		// get service reason
		CArray<Map> triggers = DBselect(getSqlExecutor(), sqlParts);
		
		CArray<CArray<Map>> rs = array();
		if (triggers != null && !triggers.isEmpty()) {
			for (Map trigger : triggers) {
				Object serviceId = Nest.value(trigger,"serviceid").$();
				unset(trigger,"serviceid");
				Nest.value(rs,serviceId).$(map(Nest.value(trigger,"triggerid").$() , trigger));
			}
		}
		return rs;
	}
	

	/**
	 * Escalates the problem triggers from the child services to their parents and adds them to slaData.
	 * The escalation will stop if a service has status calculation disabled or is in OK state.
	 *
	 * @param array services
	 * @param array serviceProblems    an array of service triggers defines as
	 *                                  array(serviceId1 => array(triggerId => trigger), ...)
	 * @param array slaData
	 * @return 
	 *
	 * @return array
	 */
	protected CArray escalateProblems(CArray<Map> services, CArray<CArray<Map>> serviceProblems, CArray slaData) {
		CArray<CArray<Map>> parentProblems = array();
		
        for (Entry<Object, CArray<Map>> e : serviceProblems.entrySet()) {
            Object serviceId = e.getKey();
            CArray<Map> problemTriggers = e.getValue();
            
            Map service = services.get(serviceId);
            
			// add the problem trigger of the current service to the data
            Nest.value(slaData,serviceId,"problems").$(rda_array_merge(Nest.value(slaData,serviceId,"problems").asCArray(), problemTriggers));
            
            // add the same trigger to the parent services
            CArray<Map> parentDependencies = Nest.value(service,"parentDependencies").asCArray();
			for (Map dependency : parentDependencies) {
				Object parentServiceId = Nest.value(dependency,"serviceupid").$();
				
				if (isset(services.get(parentServiceId))) {
					Map parentService = services.get(parentServiceId);

					// escalate only if status calculation is enabled for the parent service and it's in problem state
					if (isStatusEnabled(parentService) && Nest.value(parentService,"status").asBoolean()) {
						if (!isset(parentProblems.get(parentServiceId))) {
							Nest.value(parentProblems,parentServiceId).$(array());
						}
						Nest.value(parentProblems,parentServiceId).$( rda_array_merge(parentProblems.get(parentServiceId), problemTriggers));
					}
				}
			}
        }
        
		// propagate the problems to the parents
		if (!parentProblems.isEmpty()) {
			slaData = escalateProblems(services, parentProblems, slaData);
		}
		
		return slaData;
	}
	
	/**
	 * Returns the value of the latest service alarm before the given time.
	 *
	 * @param array serviceIds
	 * @param int beforeTime
	 *
	 * @return array
	 */
	protected CArray<Integer> fetchLatestValues(Long[] serviceIds, int beforeTime) {
		// the query will return the alarms with the maximum timestamp for each service
		// since multiple alarms can have the same timestamp, we only need to save the last one
		SqlBuilder sqlParts = new SqlBuilder();
		/* To be confirmed */
		String sql = "SELECT sa.serviceid,sa.value"+
				" FROM (SELECT MAX(sa3.servicealarmid) AS servicealarmid"+
				" FROM (SELECT sa2.serviceid,MAX(sa2.clock) AS clock"+
						" FROM service_alarms sa2"+
						" WHERE sa2.clock<"+beforeTime+
							" AND "+sqlParts.dual.dbConditionInt("sa2.serviceid", serviceIds)+
						" GROUP BY sa2.serviceid) ss"+
				" JOIN service_alarms sa3 ON sa3.serviceid = ss.serviceid and sa3.clock = ss.clock"+
				" GROUP BY sa3.serviceid) ss2"+
		" JOIN service_alarms sa ON sa.servicealarmid = ss2.servicealarmid";
		
		CArray<Map> alarms = DBselect(getSqlExecutor(), sql, sqlParts.getNamedParams());
		CArray<Integer> rs = array();
		for (Map alarm : alarms) {
			Nest.value(rs, alarm.get("serviceid")).$(Nest.value(alarm,"value").$());
		}
		return rs;
	}
		
	protected CArray<Map> fetchChildDependencies(String[] parentServiceIds, Object output) {
		CParamGet params = new CParamGet();
		params.setOutput(output);
		params.setFilter("serviceupid", parentServiceIds);
		SqlBuilder sqlParts = createSelectQueryParts("services_links", "sl", params);
		
		// sort by sortorder
		sqlParts.from.put(this.tableName()+' '+this.tableAlias());
		sqlParts.where.put("sl.servicedownid="+this.fieldId("serviceid"));
		addQueryOrder(this.fieldId("sortorder"), sqlParts);
		addQueryOrder(this.fieldId("serviceid"), sqlParts);
		
		// add permission filter
		if (CWebUser.getType() != USER_TYPE_SUPER_ADMIN) {
			addPermissionFilter(sqlParts);
		}
		return DBselect(getSqlExecutor(), sqlParts);
	}

	/**
	 * Returns an array of dependencies from the parent services to the given services.
	 * Performs permission checks.
	 *
	 * @param array childServiceIds
	 * @param output
	 * @param boolean soft             if set to true, will return only soft-linked dependencies
	 *
	 * @return array    an array of service links sorted by "sortorder" in ascending order
	 */
	protected CArray<Map> fetchParentDependencies(String[] childServiceIds, Object output) {
		return fetchParentDependencies(childServiceIds, output, null);
	}
	
	protected CArray<Map> fetchParentDependencies(String[] childServiceIds, Object output, Boolean soft) {
		CParamGet params = new CParamGet();
		params.setOutput(output);
		params.setFilter("servicedownid", childServiceIds);
		SqlBuilder sqlParts = createSelectQueryParts("services_links", "sl", params);
		
		sqlParts.from.put(this.tableName()+' '+this.tableAlias());
		sqlParts.where.put("sl.serviceupid="+this.fieldId("serviceid"));
		if (soft != null) {
			sqlParts.where.put("sl.soft=" + (soft ? 1 : 0));
		}
		addQueryOrder(this.fieldId("sortorder"), sqlParts);
		addQueryOrder(this.fieldId("serviceid"), sqlParts);
		
		// add permission filter
		if (CWebUser.getType() != USER_TYPE_SUPER_ADMIN) {
			addPermissionFilter(sqlParts);
		}
		return DBselect(getSqlExecutor(), sqlParts);
	}
	
	/**
	 * Returns true if status calculation is enabled for the given service.
	 *
	 * @param array service
	 *
	 * @return bool
	 */
	protected boolean isStatusEnabled(Map service) {
		return (Nest.value(service,"algorithm").asInteger() != SERVICE_ALGORITHM_NONE);
	}
	
	/**
	 * Validates the \"name\" field.
	 *
	 * @throws APIException if the name is missing
	 *
	 * @param array service
	 *
	 * @return void
	 */
	protected void checkName(Map service) {
		if (!isset(service,"name") || rda_empty(Nest.value(service,"name").$())) {
			throw CDB.exception(RDA_API_ERROR_PARAMETERS, _("Empty name."));
		}
	}
	
	/**
	 * Validates the \"algorithm\" field. Assumes the \"name\" field is valid.
	 *
	 * @throws APIException if the name is missing or invalid
	 *
	 * @param array service
	 *
	 * @return void
	 */
	protected void checkAlgorithm(Map service) {
		if (!isset(service,"algorithm") || empty(serviceAlgorythm(Nest.value(service,"algorithm").asInteger()))) {
			throw CDB.exception(RDA_API_ERROR_PARAMETERS, _s("Incorrect algorithm for service \"%1$s\".", Nest.value(service,"name").$()));
		}
	}
	
	/**
	 * Validates the \"showsla\" field. Assumes the \"name\" field is valid.
	 *
	 * @throws APIException if the name is missing or is not a boolean value
	 *
	 * @param array service
	 *
	 * @return void
	 */
	protected void checkShowSla(Map service) {
		Map showSlaValues = map(
			SERVICE_SHOW_SLA_OFF, true,
			SERVICE_SHOW_SLA_ON, true
		);
		if (!isset(Nest.value(service,"showsla").$()) || !isset(showSlaValues,service.get("showsla"))) {
			throw CDB.exception(RDA_API_ERROR_PARAMETERS, _s("Incorrect calculate SLA value for service \"%1$s\".", Nest.value(service,"name").$()));
		}
	}
	
	/**
	 * Validates the \"showsla\" field. Assumes the \"name\" field is valid.
	 *
	 * @throws APIException if the value is missing, or is out of bounds
	 *
	 * @param array service
	 *
	 * @return void
	 */
	protected void checkGoodSla(Map service) {
		if ((!empty(Nest.value(service,"showsla").$()) && empty(Nest.value(service,"goodsla").$()))
				|| (isset(service,"goodsla")
					&& (!is_numeric(Nest.value(service,"goodsla").$()) || Nest.value(service,"goodsla").asFloat() < 0f || Nest.value(service,"goodsla").asFloat() > 100f))) {

			throw CDB.exception(RDA_API_ERROR_PARAMETERS, _s("Incorrect acceptable SLA for service \"%1$s\".", Nest.value(service,"name").$()));
		}
	}
	
	/**
	 * Validates the \"sortorder\" field. Assumes the \"name\" field is valid.
	 *
	 * @throws APIException if the value is missing, or is out of bounds
	 *
	 * @param array service
	 *
	 * @return void
	 */
	protected void checkSortOrder(Map service) {
		if (!isset(service,"sortorder") || !rda_is_int(Nest.value(service,"sortorder").$())
			|| Nest.value(service,"sortorder").asInteger() < 0 || Nest.value(service,"sortorder").asInteger() > 999) {

			throw CDB.exception(RDA_API_ERROR_PARAMETERS, _s("Incorrect sorder order for service \"%1$s\".", Nest.value(service,"name").$()));
		}
	}
	
	/**
	 * Validates the \"triggerid\" field. Assumes the \"name\" field is valid.
	 *
	 * @throws APIException if the value is incorrect
	 *
	 * @param array service
	 *
	 * @return void
	 */
	protected void checkTriggerId(Map service) {
		if (!empty(Nest.value(service,"triggerid").$()) && !rda_is_int(Nest.value(service,"triggerid").$())) {
			throw CDB.exception(RDA_API_ERROR_PARAMETERS, _s("Incorrect trigger ID for service \"%1$s\".", Nest.value(service,"name").$()));
		}
	}
	
	/**
	 * Validates the \"parentid\" field. Assumes the \"name\" field is valid.
	 *
	 * @throws APIException if the value is incorrect
	 *
	 * @param array service
	 *
	 * @return void
	 */
	protected void checkParentId(Map service) {
		if (!empty(Nest.value(service,"parentid").$()) && !rda_is_int(Nest.value(service,"parentid").$())) {
			if (isset(service,"name")) {
				throw CDB.exception(RDA_API_ERROR_PARAMETERS, _s("Incorrect parent for service \"%1$s\".", Nest.value(service,"name").$()));
			} else {
				throw CDB.exception(RDA_API_ERROR_PARAMETERS, _("Incorrect parent service."));
			}
		}

		if (isset(service,"serviceid") && idcmp(Nest.value(service,"serviceid").$(), Nest.value(service,"parentid").$())) {
			throw CDB.exception(RDA_API_ERROR_PARAMETERS, _("Service cannot be parent and child at the same time."));
		}
	}
	
	/**
	 * Validates the \"status\" field. Assumes the \"name\" field is valid.
	 *
	 * @throws APIException if the value is incorrect
	 *
	 * @param array service
	 *
	 * @return void
	 */
	protected void checkStatus(Map service) {
		if (!empty(Nest.value(service,"status").$()) && !rda_is_int(Nest.value(service,"status").$())) {
			throw CDB.exception(RDA_API_ERROR_PARAMETERS, _s("Incorrect status for service \"%1$s\".", Nest.value(service,"name").$()));
		}
	}
	
	/**
	 * Checks that the user has read access to the given triggers.
	 *
	 * @throws APIException if the user doesn't have permission to access any of the triggers
	 *
	 * @param array services
	 *
	 * @return void
	 */
	protected void checkTriggerPermissions(CArray<Map> services) {
		CArray triggerIds = array();
		for(Map service : services) {
			if (!empty(Nest.value(service,"triggerid").$())) {
				triggerIds.add(Nest.value(service,"triggerid").$());
			}
		}
		if (!API.Trigger(this.idBean, this.getSqlExecutor()).isReadable(triggerIds.valuesAsLong())) {
			throw CDB.exception(RDA_API_ERROR_PERMISSIONS, _("No permissions to referred object or it does not exist!"));
		}
	}
	
	/**
	 * Checks that all of the given services are readable.
	 *
	 * @throws APIException if at least one of the services doesn't exist
	 *
	 * @param array serviceIds
	 *
	 * @return void
	 */
	protected void checkServicePermissions(Long... serviceIds) {
		if (!isReadable(serviceIds)) {
			throw CDB.exception(RDA_API_ERROR_PERMISSIONS, _("No permissions to referred object or it does not exist!"));
		}
	}
	
	/**
	 * Checks that none of the given services have any children.
	 *
	 * @throws APIException if at least one of the services has a child service
	 *
	 * @param array serviceIds
	 *
	 * @return void
	 */
	protected void checkThatServicesDontHaveChildren(Long... serviceIds) {
		CParamGet options = new CParamGet();
		options.setOutput(new String[]{"serviceupid"});
		options.setFilter("serviceupid", serviceIds);
		options.setFilter("soft", "0");
		options.setLimit(1);
		CArray<Map> childs = select("services_links", options);
		Map child = reset(childs);
		if (!empty(child)) {
			CServiceGet soptions = new CServiceGet();
			soptions.setOutput(new String[]{"name"});
			soptions.setServiceIds(Nest.value(child,"serviceupid").asLong());
			soptions.setLimit(1);
			CArray<Map> services = select(tableName(), soptions);
			Map service = reset(services);
			throw CDB.exception(RDA_API_ERROR_PERMISSIONS,
				_s("Service \"%1$s\" cannot be deleted, because it is dependent on another service.", Nest.value(service,"name").$())
			);
		}
	}
	
	/**
	 * Checks that the given dependency is valid.
	 *
	 * @throws APIException if the dependency is invalid
	 *
	 * @param array dependency
	 *
	 * @return void
	 */
	protected void checkDependency(Map dependency) {
		if (idcmp(Nest.value(dependency,"serviceid").$(), Nest.value(dependency,"dependsOnServiceid").$())) {
			CServiceGet soptions = new CServiceGet();
			soptions.setOutput(new String[]{"name"});
			soptions.setServiceIds(Nest.value(dependency,"serviceid").asLong());
			CArray<Map> services = select(tableName(), soptions);
			Map service = reset(services);
			throw CDB.exception(RDA_API_ERROR_PARAMETERS, _s("Service \"%1$s\" cannot be dependent on itself.", Nest.value(service,"name").$()));
		}

		// check "soft" field value
		if (!isset(Nest.value(dependency,"soft").$()) || !in_array(Nest.value(dependency,"soft").asInteger(), new int[]{0, 1}, true)) {
			CServiceGet soptions = new CServiceGet();
			soptions.setOutput(new String[]{"name"});
			soptions.setServiceIds(Nest.value(dependency,"serviceid").asLong());
			CArray<Map> services = select(tableName(), soptions);
			Map service = reset(services);
			throw CDB.exception(RDA_API_ERROR_PARAMETERS,
				_s("Incorrect \"soft\" field value for dependency for service \"%1$s\".", Nest.value(service,"name").$())
			);
		}
	}
	
	/**
	 * Checks that that none of the given services are hard linked to a different service.
	 * Assumes the dependencies are valid.
	 *
	 * @throws APIException if at a least one service is hard linked to another service
	 *
	 * @param array dependencies
	 *
	 * @return void
	 */
	protected void checkForHardlinkedDependencies(CArray<Map> dependencies) {
		// only check hard dependencies
		CArray hardDepServiceIds = array();
		for(Map dependency : dependencies) {
			if (!Nest.value(dependency,"soft").asBoolean()) {
				hardDepServiceIds.add(Nest.value(dependency,"dependsOnServiceid").$());
			}
		}

		if (!empty(hardDepServiceIds)) {
			// look for at least one hardlinked service among the given
			hardDepServiceIds = array_unique(hardDepServiceIds);
			CServiceGet soptions = new CServiceGet();
			soptions.setOutput(new String[]{"servicedownid"});
			soptions.setFilter("soft", "0");
			soptions.setFilter("servicedownid", hardDepServiceIds.valuesAsString());
			soptions.setLimit(1);
			CArray<Map> deps = select("services_links", soptions);
			if (!empty(deps)) {
				Map dep = reset(deps);
				soptions = new CServiceGet();
				soptions.setOutput(new String[]{"name"});
				soptions.setServiceIds(Nest.value(dep,"servicedownid").asLong());
				CArray<Map> services = select(tableName(), soptions);
				Map service = reset(services);
				throw CDB.exception(RDA_API_ERROR_PARAMETERS,
					_s("Service \"%1$s\" is already hardlinked to a different service.", Nest.value(service,"name").$())
				);
			}
		}
	}
	
	/**
	 * Checks that none of the parent services are linked to a trigger. Assumes the dependencies are valid.
	 *
	 * @throws APIException if at least one of the parent services is linked to a trigger
	 *
	 * @param array dependencies
	 *
	 * @return void
	 */
	protected void checkThatParentsDontHaveTriggers(CArray<Map> dependencies) {
		CArray parentServiceIds = array_unique(rda_objectValues(dependencies, "serviceid"));
		if (!empty(parentServiceIds)) {
			SqlBuilder sqlParts = new SqlBuilder();
			CArray<Map> query = DBselect(
				getSqlExecutor(),
				"SELECT s.triggerid,s.name"+
					" FROM services s "+
					" WHERE "+sqlParts.dual.dbConditionInt("s.serviceid", parentServiceIds.valuesAsLong())+
					" AND s.triggerid IS NOT NULL", 1,
				sqlParts.getNamedParams());
			Map parentService = DBfetch(query);
			if (!empty(parentService)) {
				throw CDB.exception(RDA_API_ERROR_PARAMETERS,
					_s("Service \"%1$s\" cannot be linked to a trigger and have children at the same time.", Nest.value(parentService,"name").$()));
			}
		}
	}
	
	/**
	 * Checks that dependencies will not create cycles in service dependencies.
	 *
	 * @throws APIException if at least one cycle is possible
	 *
	 * @param array depsToValid	dependency list to be validated
	 *
	 * @return void
	 */
	protected void checkForCircularityInDependencies(CArray<Map> depsToValid) {
		CServiceGet soptions = new CServiceGet();
		soptions.setOutput(new String[]{"serviceupid", "servicedownid"});
		CArray<Map> dbDeps = select("services_links", soptions);

		// create existing dependency acyclic graph
		CArray arr = array();
		for(Map dbDep : dbDeps) {
			if (!isset(arr,dbDep.get("serviceupid"))) {
				Nest.value(arr,dbDep.get("serviceupid")).$(array());
			}
			Nest.value(arr,dbDep.get("serviceupid"),dbDep.get("servicedownid")).$(Nest.value(dbDep,"servicedownid").$());
		}

		// check for circularity and add dependencies to the graph
		for(Map dep:depsToValid) {
			dfCircularitySearch(Nest.value(dep,"serviceid").asString(), Nest.value(dep,"dependsOnServiceid").asString(), arr);
			Nest.value(arr,dep.get("serviceid"),dep.get("dependsOnServiceid")).$(Nest.value(dep,"dependsOnServiceid").$());
		}
	}
	
	/**
	 * Depth First Search recursive function to find circularity and rise exception.
	 *
	 * @throws APIException if cycle is possible
	 *
	 * @param int id	dependency from id
	 * @param int depId	dependency to id
	 * @param ref arr	reference to graph structure. Structure is associative array with keys as \"from id\"
	 *			and values as arrays with keys and values as \"to id\".
	 *
	 * @return void
	 */
	protected void dfCircularitySearch(String id, String depId, CArray arr) {
		if (id.equals(depId)) {
			// cycle found
			throw CDB.exception(RDA_API_ERROR_PARAMETERS, _("Services form a circular dependency."));
		}
		if (isset(arr,depId)) {
			for(Object dep : Nest.value(arr,depId).asCArray()) {
				dfCircularitySearch(id, Nest.as(dep).asString(), arr);
			}
		}
	}
	
	/**
	 * Checks that the given service time is valid.
	 *
	 * @throws APIException if the service time is invalid
	 *
	 * @param array serviceTime
	 *
	 * @return void
	 */
	protected void checkTime(Map serviceTime) {
		if (empty(Nest.value(serviceTime,"serviceid").$())) {
			throw CDB.exception(RDA_API_ERROR_PARAMETERS, _("Invalid method parameters."));
		}
		checkServiceTime(serviceTime);
	}
	
	@Override
	protected void applyQueryFilterOptions(String tableName, String tableAlias, CParamGet params, SqlBuilder sqlParts) {
		if (CWebUser.getType() != USER_TYPE_SUPER_ADMIN) {
			// if services with specific trigger IDs were requested, return only the ones accessible to the current user.
			if (!empty(Nest.value(params.getFilter(),"triggerid").$())) {
				CTriggerGet options = new CTriggerGet();
				options.setTriggerIds(Nest.value(params.getFilter(),"triggerid").asLong());
				CArray<Map> accessibleTriggers = API.Trigger(this.idBean, this.getSqlExecutor()).get(options);
				Nest.value(params.getFilter(),"triggerid").$(rda_objectValues(accessibleTriggers, "triggerid"));
			} else {// otherwise return services with either no triggers, or any trigger accessible to the current user
				addPermissionFilter(sqlParts);
			}
		}
		
		super.applyQueryFilterOptions(tableName, tableAlias, params, sqlParts);
		
		// parentids
		if (params.get("parentids") != null) {
			sqlParts.from.put("services_links slp");
			sqlParts.where.put(this.fieldId("serviceid")+"=slp.servicedownid AND slp.soft=0");
			sqlParts.where.dbConditionInt("slp.serviceupid", Nest.array(params, "parentids").asLong());
		}
		
		// childids
		if (params.get("childids") != null) {
			sqlParts.from.put("services_links slc");
			sqlParts.where.put(this.fieldId("serviceid")+"=slc.serviceupid AND slc.soft=0");
			sqlParts.where.dbConditionInt("slc.servicedownid", Nest.array(params, "childids").asLong());
		}
	}

	@Override
	protected void addRelatedObjects(CServiceGet params, CArray<Map> result) {
		super.addRelatedObjects(params, result);
		
		String[] serviceIds = result.keys();
		
		// selectDependencies
		if (!is_null(params.getSelectDependencies()) && !API_OUTPUT_COUNT.equals(params.getSelectDependencies())) {
			CArray<Map> dependencies = fetchChildDependencies(serviceIds,
				outputExtend("services_links", new String[]{"serviceupid", "linkid"}, params.getSelectDependencies())
			);
			dependencies = rda_toHash(dependencies, "linkid");
			CRelationMap relationMap = createRelationMap(dependencies, "serviceupid", "linkid");
			
			unsetExtraFields(dependencies, new String[]{"serviceupid", "linkid"}, params.getSelectDependencies());
			relationMap.mapMany(result, dependencies, "dependencies");
		}
		
		// selectParentDependencies
		if (!is_null(params.getSelectParentDependencies()) && !API_OUTPUT_COUNT.equals(params.getSelectParentDependencies())) {
			CArray<Map> dependencies = fetchParentDependencies(serviceIds,
				outputExtend("services_links", new String[]{"servicedownid", "linkid"}, params.getSelectParentDependencies())
			);
			dependencies = rda_toHash(dependencies, "linkid");
			CRelationMap relationMap = createRelationMap(dependencies, "servicedownid", "linkid");
			
			unsetExtraFields(dependencies, new String[]{"servicedownid", "linkid"}, params.getSelectParentDependencies());
			relationMap.mapMany(result, dependencies, "parentDependencies");
		}
		
		// selectParent
		if (!is_null(params.getSelectParent()) && !API_OUTPUT_COUNT.equals(params.getSelectParent())) {
			CArray<Map> dependencies = fetchParentDependencies(serviceIds, new String[]{"servicedownid", "serviceupid"}, false);
			CRelationMap relationMap = createRelationMap(dependencies, "servicedownid", "serviceupid");
			CServiceGet options = new CServiceGet();
			options.setOutput(params.getSelectParent());
			options.setServiceIds(relationMap.getRelatedLongIds());
			options.setPreserveKeys(true);
			CArray<Map> parents = get(options);
			relationMap.mapOne(result, parents, "parent");
		}
		
		// selectTimes
		if (!is_null(params.getSelectTimes()) && !API_OUTPUT_COUNT.equals(params.getSelectTimes())) {
			CParamGet get = new CParamGet();
			get.setOutput(outputExtend("services_times", new String[]{"serviceid", "timeid"}, params.getSelectTimes()));
			get.setFilter("serviceid", serviceIds);
			get.setPreserveKeys(true);
			
			CArray<Map> serviceTimes = select("services_times", get);
			CRelationMap relationMap = createRelationMap(serviceTimes, "serviceid", "timeid");
			
			unsetExtraFields(serviceTimes, new String[]{"serviceid", "timeid"}, params.getSelectTimes());
			relationMap.mapMany(result, serviceTimes, "times");
		}
		
		// selectAlarms
		if (!is_null(params.getSelectAlarms()) && !API_OUTPUT_COUNT.equals(params.getSelectAlarms())) {
			CParamGet get = new CParamGet();
			get.setOutput(outputExtend("service_alarms", new String[]{"serviceid", "servicealarmid"}, params.getSelectAlarms()));
			get.setFilter("serviceid", serviceIds);
			get.setPreserveKeys(true);
			
			CArray<Map> serviceAlarms = select("service_alarms", get);
			CRelationMap relationMap = createRelationMap(serviceAlarms, "serviceid", "servicealarmid");
			
			unsetExtraFields(serviceAlarms, new String[]{"serviceid", "servicealarmid"}, params.getSelectAlarms());
			relationMap.mapMany(result, serviceAlarms, "alarms");
		}
		
		// selectTrigger
		if (!is_null(params.getSelectTrigger()) && !API_OUTPUT_COUNT.equals(params.getSelectTrigger())) {
			CRelationMap relationMap = createRelationMap(result, "serviceid", "triggerid");
			
			CParamGet get = new CParamGet();
			get.setOutput(params.getSelectTrigger());
			get.put("triggerids", relationMap.getRelatedLongIds());
			get.setPreserveKeys(true);
			
			CArray<Map> triggers = select("triggers",get);
			relationMap.mapOne(result, triggers, "trigger");
		}
	}

	@Override
	protected void applyQueryOutputOptions(String tableName, String tableAlias, CParamGet params, SqlBuilder sqlParts) {
		super.applyQueryOutputOptions(tableName, tableAlias, params, sqlParts);
		if (params.getCountOutput() == null) {
			if (params.get("selectTrigger") != null) {
				addQuerySelect(fieldId("triggerid"), sqlParts);
			}
		}
	}
	
	/**
	 * Add permission filter SQL query part
	 *
	 * @param array sqlParts
	 *
	 * @return string
	 */
	protected void addPermissionFilter(SqlBuilder sqlParts) {
		String userid = Nest.value(userData(), "userid").asString();
		List<Long> userGroups = getUserGroupsByUserId(this.idBean, getSqlExecutor(),userid);
		Long[] usergrpIds = userGroups.toArray(new Long[0]);
		sqlParts.where.dbConditionInt("r.groupid", usergrpIds,
				new SqlDecorator() {
					@Override
					public String decorate(String sql) {
						return "(EXISTS ("+
								"SELECT NULL"+
								" FROM functions f,items i,hosts_groups hgg"+
								" JOIN rights r"+
									" ON r.tenantid=hgg.tenantid"+ 
									" AND r.id=hgg.groupid"+
									" AND "+sql+
								" WHERE s.tenantid=f.tenantid"+
									" AND f.tenantid=i.tenantid"+
									" AND i.tenantid=hgg.tenantid"+
									" AND s.triggerid=f.triggerid"+
									" AND f.itemid=i.itemid"+
									" AND i.hostid=hgg.hostid"+
								" GROUP BY f.triggerid"+
								" HAVING MIN(r.permission)>"+PERM_DENY+
								")"+
							" OR s.triggerid IS NULL)";
					}
				}
		);
	}
}
