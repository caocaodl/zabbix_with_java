Raphael = (function() {
	var j = /[, ]+/, C0 = /^(circle|rect|path|ellipse|text|image)$/, O = "prototype", Q = "hasOwnProperty", T = document, U0 = window, n = {
		was : Object[O][Q].call(U0, "Raphael"),
		is : U0.Raphael
	}, k0 = function() {
		if (k0.is(arguments[0], "array")) {
			var _ = arguments[0], A = z[c](k0, _.splice(0, 3 + k0.is(_[0], g0))), B = A
					.set();
			for (var C = 0, D = _[k]; C < D; C++) {
				var $ = _[C] || {};
				C0.test($.type) && B[f](A[$.type]().attr($))
			}
			return B
		}
		return z[c](k0, arguments)
	}, X = function() {
	}, I0 = "appendChild", c = "apply", V = "concat", T0 = "", e0 = " ", E = "split", L = "click dblclick mousedown mousemove mouseout mouseover mouseup"[E](e0), a0 = "join", k = "length", A0 = String[O].toLowerCase, $1 = Math, q = $1.max, D0 = $1.min, g0 = "number", M0 = "toString", X0 = Object[O][M0], D = {}, H0 = $1.pow, f = "push", Z = /^(?=[\da-f]$)/, i = /^url\(['"]?([^\)]+?)['"]?\)$/i, B = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgb\(\s*([\d\.]+\s*,\s*[\d\.]+\s*,\s*[\d\.]+)\s*\)|rgb\(\s*([\d\.]+%\s*,\s*[\d\.]+%\s*,\s*[\d\.]+%)\s*\)|hs[bl]\(\s*([\d\.]+\s*,\s*[\d\.]+\s*,\s*[\d\.]+)\s*\)|hs[bl]\(\s*([\d\.]+%\s*,\s*[\d\.]+%\s*,\s*[\d\.]+%)\s*\))\s*$/i, N = $1.round, $0 = "setAttribute", v0 = parseFloat, M = parseInt, J0 = String[O].toUpperCase, p = {
		blur : 0,
		"clip-rect" : "0 0 1e9 1e9",
		cursor : "default",
		cx : 0,
		cy : 0,
		fill : "#fff",
		"fill-opacity" : 1,
		font : "10px \"Arial\"",
		"font-family" : "\"Arial\"",
		"font-size" : "10",
		"font-style" : "normal",
		"font-weight" : 400,
		gradient : 0,
		height : 0,
		href : "http://raphaeljs.com/",
		opacity : 1,
		path : "M0,0",
		r : 0,
		rotation : 0,
		rx : 0,
		ry : 0,
		scale : "1 1",
		src : "",
		stroke : "#000",
		"stroke-dasharray" : "",
		"stroke-linecap" : "butt",
		"stroke-linejoin" : "butt",
		"stroke-miterlimit" : 0,
		"stroke-opacity" : 1,
		"stroke-width" : 1,
		target : "_blank",
		"text-anchor" : "middle",
		title : "Raphael",
		translation : "0 0",
		width : 0,
		x : 0,
		y : 0
	}, u0 = {
		along : "along",
		blur : g0,
		"clip-rect" : "csv",
		cx : g0,
		cy : g0,
		fill : "colour",
		"fill-opacity" : g0,
		"font-size" : g0,
		height : g0,
		opacity : g0,
		path : "path",
		r : g0,
		rotation : "csv",
		rx : g0,
		ry : g0,
		scale : "csv",
		stroke : "colour",
		"stroke-opacity" : g0,
		"stroke-width" : g0,
		translation : "csv",
		width : g0,
		x : g0,
		y : g0
	}, B0 = "replace";
	k0.version = "1.3.2";
	k0.type = (U0.SVGAngle
			|| T.implementation.hasFeature(
					"http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1")
			? "SVG"
			: "VML");
	if (k0.type == "VML") {
		var l0 = T.createElement("div");
		l0.innerHTML = "<!--[if vml]><br><br><![endif]-->";
		if (l0.childNodes[k] != 2)
			return k0.type = null;
		l0 = null
	}
	k0.svg = !(k0.vml = k0.type == "VML");
	X[O] = k0[O];
	k0._id = 0;
	k0._oid = 0;
	k0.fn = {};
	k0.is = function(_, $) {
		$ = A0.call($);
		return (($ == "object" || $ == "undefined") && typeof _ == $)
				|| (_ == null && $ == "null")
				|| A0.call(X0.call(_).slice(8, -1)) == $
	};
	k0.setWindow = function($) {
		U0 = $;
		T = U0.document
	};
	var P0 = function(A) {
		if (k0.vml) {
			var _ = /^\s+|\s+$/g;
			P0 = s0(function(A) {
						var $;
						A = (A + T0)[B0](_, T0);
						try {
							var B = new U0.ActiveXObject("htmlfile");
							B.write("<body>");
							B.close();
							$ = B.body
						} catch (D) {
							$ = U0.createPopup().document.body
						}
						var E = $.createTextRange();
						try {
							$.style.color = A;
							var C = E.queryCommandValue("ForeColor");
							C = ((C & 255) << 16) | (C & 65280)
									| ((C & 16711680) >>> 16);
							return "#" + ("000000" + C[M0](16)).slice(-6)
						} catch (D) {
							return "none"
						}
					})
		} else {
			var $ = T.createElement("i");
			$.title = "Rapha\xebl Colour Picker";
			$.style.display = "none";
			T.body[I0]($);
			P0 = s0(function(_) {
						$.style.color = _;
						return T.defaultView.getComputedStyle($, T0)
								.getPropertyValue("color")
					})
		}
		return P0(A)
	}, p0 = function() {
		return "hsb(" + [this.h, this.s, this.b] + ")"
	}, r = function() {
		return this.hex
	};
	k0.hsb2rgb = s0(function(G, L, B) {
				if (k0.is(G, "object") && "h" in G && "s" in G && "b" in G) {
					B = G.b;
					L = G.s;
					G = G.h
				}
				var F, D, C;
				if (B == 0)
					return {
						r : 0,
						g : 0,
						b : 0,
						hex : "#000"
					};
				if (G > 1 || L > 1 || B > 1) {
					G /= 255;
					L /= 255;
					B /= 255
				}
				var K = ~~(G * 6), H = (G * 6) - K, $ = B * (1 - L), A = B
						* (1 - (L * H)), E = B * (1 - (L * (1 - H)));
				F = [B, A, $, $, E, B, B][K];
				D = [E, B, B, A, $, $, E][K];
				C = [$, $, E, B, B, A, $][K];
				F *= 255;
				D *= 255;
				C *= 255;
				var I = {
					r : F,
					g : D,
					b : C,
					toString : r
				}, _ = (~~F)[M0](16), M = (~~D)[M0](16), J = (~~C)[M0](16);
				_ = _[B0](Z, "0");
				M = M[B0](Z, "0");
				J = J[B0](Z, "0");
				I.hex = "#" + _ + M + J;
				return I
			}, k0);
	k0.rgb2hsb = s0(function(_, A, F) {
				if (k0.is(_, "object") && "r" in _ && "g" in _ && "b" in _) {
					F = _.b;
					A = _.g;
					_ = _.r
				}
				if (k0.is(_, "string")) {
					var D = k0.getRGB(_);
					_ = D.r;
					A = D.g;
					F = D.b
				}
				if (_ > 1 || A > 1 || F > 1) {
					_ /= 255;
					A /= 255;
					F /= 255
				}
				var E = q(_, A, F), H = D0(_, A, F), C, $, B = E;
				if (H == E)
					return {
						h : 0,
						s : 0,
						b : E
					};
				else {
					var G = (E - H);
					$ = G / E;
					if (_ == E)
						C = (A - F) / G;
					else if (A == E)
						C = 2 + ((F - _) / G);
					else
						C = 4 + ((_ - A) / G);
					C /= 6;
					C < 0 && C++;
					C > 1 && C--
				}
				return {
					h : C,
					s : $,
					b : B,
					toString : p0
				}
			}, k0);
	var Q0 = /,?([achlmqrstvxz]),?/gi;
	k0._path2string = function() {
		return this.join(",")[B0](Q0, "$1")
	};
	function s0($, A, _) {
		function B() {
			var D = Array[O].slice.call(arguments, 0), E = D[a0]("\u25ba"), C = B.cache = B.cache
					|| {}, F = B.count = B.count || [];
			if (C[Q](E))
				return _ ? _(C[E]) : C[E];
			F[k] >= 1000 && delete C[F.shift()];
			F[f](E);
			C[E] = $[c](A, D);
			return _ ? _(C[E]) : C[E]
		}
		return B
	}
	k0.getRGB = s0(function(_) {
				if (!_ || !!((_ = _ + T0).indexOf("-") + 1))
					return {
						r : -1,
						g : -1,
						b : -1,
						hex : "none",
						error : 1
					};
				if (_ == "none")
					return {
						r : -1,
						g : -1,
						b : -1,
						hex : "none"
					};
				!(({
					hs : 1,
					rg : 1
				})[Q](_.substring(0, 2)) || _.charAt() == "#") && (_ = P0(_));
				var C, J, $, I, F, G = _.match(B);
				if (G) {
					if (G[2]) {
						I = M(G[2].substring(5), 16);
						$ = M(G[2].substring(3, 5), 16);
						J = M(G[2].substring(1, 3), 16)
					}
					if (G[3]) {
						I = M((F = G[3].charAt(3)) + F, 16);
						$ = M((F = G[3].charAt(2)) + F, 16);
						J = M((F = G[3].charAt(1)) + F, 16)
					}
					if (G[4]) {
						G = G[4][E](/\s*,\s*/);
						J = v0(G[0]);
						$ = v0(G[1]);
						I = v0(G[2])
					}
					if (G[5]) {
						G = G[5][E](/\s*,\s*/);
						J = v0(G[0]) * 2.55;
						$ = v0(G[1]) * 2.55;
						I = v0(G[2]) * 2.55
					}
					if (G[6]) {
						G = G[6][E](/\s*,\s*/);
						J = v0(G[0]);
						$ = v0(G[1]);
						I = v0(G[2]);
						return k0.hsb2rgb(J, $, I)
					}
					if (G[7]) {
						G = G[7][E](/\s*,\s*/);
						J = v0(G[0]) * 2.55;
						$ = v0(G[1]) * 2.55;
						I = v0(G[2]) * 2.55;
						return k0.hsb2rgb(J, $, I)
					}
					G = {
						r : J,
						g : $,
						b : I
					};
					var A = (~~J)[M0](16), D = (~~$)[M0](16), H = (~~I)[M0](16);
					A = A[B0](Z, "0");
					D = D[B0](Z, "0");
					H = H[B0](Z, "0");
					G.hex = "#" + A + D + H;
					return G
				}
				return {
					r : -1,
					g : -1,
					b : -1,
					hex : "none",
					error : 1
				}
			}, k0);
	k0.getColor = function(_) {
		var A = this.getColor.start = this.getColor.start || {
			h : 0,
			s : 1,
			b : _ || 0.75
		}, $ = this.hsb2rgb(A.h, A.s, A.b);
		A.h += 0.075;
		if (A.h > 1) {
			A.h = 0;
			A.s -= 0.2;
			A.s <= 0 && (this.getColor.start = {
				h : 0,
				s : 1,
				b : A.b
			})
		}
		return $.hex
	};
	k0.getColor.reset = function() {
		delete this.start
	};
	var V0 = /([achlmqstvz])[\s,]*((-?\d*\.?\d*(?:e[-+]?\d+)?\s*,?\s*)+)/ig, f0 = /(-?\d*\.?\d*(?:e[-+]?\d+)?)\s*,?\s*/ig;
	k0.parsePathString = s0(function($) {
				if (!$)
					return null;
				var A = {
					a : 7,
					c : 6,
					h : 1,
					l : 2,
					m : 2,
					q : 4,
					s : 4,
					t : 2,
					v : 1,
					z : 0
				}, _ = [];
				if (k0.is($, "array") && k0.is($[0], "array"))
					_ = W0($);
				if (!_[k])
					($ + T0)[B0](V0, function(C, $, E) {
								var D = [], B = A0.call($);
								E[B0](f0, function($, _) {
											_ && D[f](+_)
										});
								if (B == "m" && D[k] > 2) {
									_[f]([$][V](D.splice(0, 2)));
									B = "l";
									$ = $ == "m" ? "l" : "L"
								}
								while (D[k] >= A[B]) {
									_[f]([$][V](D.splice(0, A[B])));
									if (!A[B])
										break
								}
							});
				_[M0] = k0._path2string;
				return _
			});
	k0.findDotsAtSegment = function(A, _, F, D, Q, L, S, R, H) {
		var P = 1 - H, O = H0(P, 3) * A + H0(P, 2) * 3 * H * F + P * 3 * H * H
				* Q + H0(H, 3) * S, M = H0(P, 3) * _ + H0(P, 2) * 3 * H * D + P
				* 3 * H * H * L + H0(H, 3) * R, K = A + 2 * H * (F - A) + H * H
				* (Q - 2 * F + A), J = _ + 2 * H * (D - _) + H * H
				* (L - 2 * D + _), E = F + 2 * H * (Q - F) + H * H
				* (S - 2 * Q + F), C = D + 2 * H * (L - D) + H * H
				* (R - 2 * L + D), G = (1 - H) * A + H * F, N = (1 - H) * _ + H
				* D, $ = (1 - H) * Q + H * S, B = (1 - H) * L + H * R, I = (90 - $1
				.atan((K - E) / (J - C))
				* 180 / $1.PI);
		(K > E || J < C) && (I += 180);
		return {
			x : O,
			y : M,
			m : {
				x : K,
				y : J
			},
			n : {
				x : E,
				y : C
			},
			start : {
				x : G,
				y : N
			},
			end : {
				x : $,
				y : B
			},
			alpha : I
		}
	};
	var Y = s0(function(G) {
				if (!G)
					return {
						x : 0,
						y : 0,
						width : 0,
						height : 0
					};
				G = F(G);
				var J = 0, I = 0, C = [], A = [], $;
				for (var B = 0, E = G[k]; B < E; B++) {
					$ = G[B];
					if ($[0] == "M") {
						J = $[1];
						I = $[2];
						C[f](J);
						A[f](I)
					} else {
						var H = O0(J, I, $[1], $[2], $[3], $[4], $[5], $[6]);
						C = C[V](H.min.x, H.max.x);
						A = A[V](H.min.y, H.max.y);
						J = $[5];
						I = $[6]
					}
				}
				var _ = D0[c](0, C), D = D0[c](0, A);
				return {
					x : _,
					y : D,
					width : q[c](0, C) - _,
					height : q[c](0, A) - D
				}
			}), W0 = function(D) {
		var $ = [];
		if (!k0.is(D, "array") || !k0.is(D && D[0], "array"))
			D = k0.parsePathString(D);
		for (var A = 0, C = D[k]; A < C; A++) {
			$[A] = [];
			for (var _ = 0, B = D[A][k]; _ < B; _++)
				$[A][_] = D[A][_]
		}
		$[M0] = k0._path2string;
		return $
	}, y0 = s0(function(F) {
				if (!k0.is(F, "array") || !k0.is(F && F[0], "array"))
					F = k0.parsePathString(F);
				var I = [], K = 0, J = 0, E = 0, C = 0, $ = 0;
				if (F[0][0] == "M") {
					K = F[0][1];
					J = F[0][2];
					E = K;
					C = J;
					$++;
					I[f](["M", K, J])
				}
				for (var M = $, G = F[k]; M < G; M++) {
					var _ = I[M] = [], B = F[M];
					if (B[0] != A0.call(B[0])) {
						_[0] = A0.call(B[0]);
						switch (_[0]) {
							case "a" :
								_[1] = B[1];
								_[2] = B[2];
								_[3] = B[3];
								_[4] = B[4];
								_[5] = B[5];
								_[6] = +(B[6] - K).toFixed(3);
								_[7] = +(B[7] - J).toFixed(3);
								break;
							case "v" :
								_[1] = +(B[1] - J).toFixed(3);
								break;
							case "m" :
								E = B[1];
								C = B[2];
							default :
								for (var L = 1, N = B[k]; L < N; L++)
									_[L] = +(B[L] - ((L % 2) ? K : J))
											.toFixed(3)
						}
					} else {
						_ = I[M] = [];
						if (B[0] == "m") {
							E = B[1] + K;
							C = B[2] + J
						}
						for (var D = 0, A = B[k]; D < A; D++)
							I[M][D] = B[D]
					}
					var H = I[M][k];
					switch (I[M][0]) {
						case "z" :
							K = E;
							J = C;
							break;
						case "h" :
							K += +I[M][H - 1];
							break;
						case "v" :
							J += +I[M][H - 1];
							break;
						default :
							K += +I[M][H - 2];
							J += +I[M][H - 1]
					}
				}
				I[M0] = k0._path2string;
				return I
			}, 0, W0), u = s0(function(F) {
				if (!k0.is(F, "array") || !k0.is(F && F[0], "array"))
					F = k0.parsePathString(F);
				var G = [], I = 0, H = 0, C = 0, B = 0, $ = 0;
				if (F[0][0] == "M") {
					I = +F[0][1];
					H = +F[0][2];
					C = I;
					B = H;
					$++;
					G[0] = ["M", I, H]
				}
				for (var L = $, E = F[k]; L < E; L++) {
					var _ = G[L] = [], J = F[L];
					if (J[0] != J0.call(J[0])) {
						_[0] = J0.call(J[0]);
						switch (_[0]) {
							case "A" :
								_[1] = J[1];
								_[2] = J[2];
								_[3] = J[3];
								_[4] = J[4];
								_[5] = J[5];
								_[6] = +(J[6] + I);
								_[7] = +(J[7] + H);
								break;
							case "V" :
								_[1] = +J[1] + H;
								break;
							case "H" :
								_[1] = +J[1] + I;
								break;
							case "M" :
								C = +J[1] + I;
								B = +J[2] + H;
							default :
								for (var K = 1, M = J[k]; K < M; K++)
									_[K] = +J[K] + ((K % 2) ? I : H)
						}
					} else
						for (var D = 0, A = J[k]; D < A; D++)
							G[L][D] = J[D];
					switch (_[0]) {
						case "Z" :
							I = C;
							H = B;
							break;
						case "H" :
							I = _[1];
							break;
						case "V" :
							H = _[1];
							break;
						default :
							I = G[L][G[L][k] - 2];
							H = G[L][G[L][k] - 1]
					}
				}
				G[M0] = k0._path2string;
				return G
			}, null, W0), d = function(A, $, _, B) {
		return [A, $, _, B, _, B]
	}, F0 = function(A, $, D, C, _, F) {
		var B = 1 / 3, E = 2 / 3;
		return [B * A + E * D, B * $ + E * C, B * _ + E * D, B * F + E * C, _,
				F]
	}, I = function(S, l, J, G, U, X, R, Q, j, L) {
		var T = $1.PI, H = T * 120 / 180, d = T / 180 * (+U || 0), D = [], C, g = s0(
				function(B, $, C) {
					var _ = B * $1.cos(C) - $ * $1.sin(C), A = B * $1.sin(C)
							+ $ * $1.cos(C);
					return {
						x : _,
						y : A
					}
				});
		if (!L) {
			C = g(S, l, -d);
			S = C.x;
			l = C.y;
			C = g(Q, j, -d);
			Q = C.x;
			j = C.y;
			var e = $1.cos(T / 180 * U), Z = $1.sin(T / 180 * U), A = (S - Q)
					/ 2, _ = (l - j) / 2, i = (A * A) / (J * J) + (_ * _)
					/ (G * G);
			if (i > 1) {
				i = $1.sqrt(i);
				J = i * J;
				G = i * G
			}
			var $ = J * J, o = G * G, u = (X == R ? -1 : 1)
					* $1.sqrt($1.abs(($ * o - $ * _ * _ - o * A * A)
							/ ($ * _ * _ + o * A * A))), N = u * J * _ / G
					+ (S + Q) / 2, M = u * -G * A / J + (l + j) / 2, W = $1
					.asin(((l - M) / G).toFixed(7)), c = $1.asin(((j - M) / G)
					.toFixed(7));
			W = S < N ? T - W : W;
			c = Q < N ? T - c : c;
			W < 0 && (W = T * 2 + W);
			c < 0 && (c = T * 2 + c);
			if (R && W > c)
				W = W - T * 2;
			if (!R && c > W)
				c = c - T * 2
		} else {
			W = L[0];
			c = L[1];
			N = L[2];
			M = L[3]
		}
		var P = c - W;
		if ($1.abs(P) > H) {
			var O = c, K = Q, Y = j;
			c = W + H * (R && c > W ? 1 : -1);
			Q = N + J * $1.cos(c);
			j = M + G * $1.sin(c);
			D = I(Q, j, J, G, U, 0, R, K, Y, [c, O, N, M])
		}
		P = c - W;
		var b = $1.cos(W), n = $1.sin(W), a = $1.cos(c), m = $1.sin(c), q = $1
				.tan(P / 4), p = 4 / 3 * J * q, r = 4 / 3 * G * q, f = [S, l], h = [
				S + p * n, l - r * b], t = [Q + p * m, j - r * a], v = [Q, j];
		h[0] = 2 * f[0] - h[0];
		h[1] = 2 * f[1] - h[1];
		if (L)
			return [h, t, v][V](D);
		else {
			D = [h, t, v][V](D)[a0]()[E](",");
			var B = [];
			for (var s = 0, F = D[k]; s < F; s++)
				B[s] = s % 2 ? g(D[s - 1], D[s], d).y : g(D[s], D[s + 1], d).x;
			return B
		}
	}, P = function(A, _, $, H, G, F, E, B, D) {
		var C = 1 - D;
		return {
			x : H0(C, 3) * A + H0(C, 2) * 3 * D * $ + C * 3 * D * D * G
					+ H0(D, 3) * E,
			y : H0(C, 3) * _ + H0(C, 2) * 3 * D * H + C * 3 * D * D * F
					+ H0(D, 3) * B
		}
	}, O0 = s0(function(B, _, G, $, F, D, J, N) {
		var C = (F - 2 * G + B) - (J - 2 * F + G), I = 2 * (G - B) - 2
				* (F - G), M = B - G, L = (-I + $1.sqrt(I * I - 4 * C * M)) / 2
				/ C, E = (-I - $1.sqrt(I * I - 4 * C * M)) / 2 / C, H = [_, N], K = [
				B, J], A;
		$1.abs(L) > 1000000000000 && (L = 0.5);
		$1.abs(E) > 1000000000000 && (E = 0.5);
		if (L > 0 && L < 1) {
			A = P(B, _, G, $, F, D, J, N, L);
			K[f](A.x);
			H[f](A.y)
		}
		if (E > 0 && E < 1) {
			A = P(B, _, G, $, F, D, J, N, E);
			K[f](A.x);
			H[f](A.y)
		}
		C = (D - 2 * $ + _) - (N - 2 * D + $);
		I = 2 * ($ - _) - 2 * (D - $);
		M = _ - $;
		L = (-I + $1.sqrt(I * I - 4 * C * M)) / 2 / C;
		E = (-I - $1.sqrt(I * I - 4 * C * M)) / 2 / C;
		$1.abs(L) > 1000000000000 && (L = 0.5);
		$1.abs(E) > 1000000000000 && (E = 0.5);
		if (L > 0 && L < 1) {
			A = P(B, _, G, $, F, D, J, N, L);
			K[f](A.x);
			H[f](A.y)
		}
		if (E > 0 && E < 1) {
			A = P(B, _, G, $, F, D, J, N, E);
			K[f](A.x);
			H[f](A.y)
		}
		return {
			min : {
				x : D0[c](0, K),
				y : D0[c](0, H)
			},
			max : {
				x : q[c](0, K),
				y : q[c](0, H)
			}
		}
	}), F = s0(function(E, H) {
				var F = u(E), J = H && u(H), K = {
					x : 0,
					y : 0,
					bx : 0,
					by : 0,
					X : 0,
					Y : 0,
					qx : null,
					qy : null
				}, _ = {
					x : 0,
					y : 0,
					bx : 0,
					by : 0,
					X : 0,
					Y : 0,
					qx : null,
					qy : null
				}, L = function(A, $) {
					var B, _;
					if (!A)
						return ["C", $.x, $.y, $.x, $.y, $.x, $.y];
					!(A[0] in {
						T : 1,
						Q : 1
					}) && ($.qx = $.qy = null);
					switch (A[0]) {
						case "M" :
							$.X = A[1];
							$.Y = A[2];
							break;
						case "A" :
							A = ["C"][V](I[c](0, [$.x, $.y][V](A.slice(1))));
							break;
						case "S" :
							B = $.x + ($.x - ($.bx || $.x));
							_ = $.y + ($.y - ($.by || $.y));
							A = ["C", B, _][V](A.slice(1));
							break;
						case "T" :
							$.qx = $.x + ($.x - ($.qx || $.x));
							$.qy = $.y + ($.y - ($.qy || $.y));
							A = ["C"][V](F0($.x, $.y, $.qx, $.qy, A[1], A[2]));
							break;
						case "Q" :
							$.qx = A[1];
							$.qy = A[2];
							A = ["C"][V](F0($.x, $.y, A[1], A[2], A[3], A[4]));
							break;
						case "L" :
							A = ["C"][V](d($.x, $.y, A[1], A[2]));
							break;
						case "H" :
							A = ["C"][V](d($.x, $.y, A[1], $.y));
							break;
						case "V" :
							A = ["C"][V](d($.x, $.y, $.x, A[1]));
							break;
						case "Z" :
							A = ["C"][V](d($.x, $.y, $.X, $.Y));
							break
					}
					return A
				}, A = function(A, $) {
					if (A[$][k] > 7) {
						A[$].shift();
						var _ = A[$];
						while (_[k])
							A.splice($++, 0, ["C"][V](_.splice(0, 6)));
						A.splice($, 1);
						B = q(F[k], J && J[k] || 0)
					}
				}, $ = function(C, A, $, D, _) {
					if (C && A && C[_][0] == "M" && A[_][0] != "M") {
						A.splice(_, 0, ["M", D.x, D.y]);
						$.bx = 0;
						$.by = 0;
						$.x = C[_][1];
						$.y = C[_][2];
						B = q(F[k], J && J[k] || 0)
					}
				};
				for (var N = 0, B = q(F[k], J && J[k] || 0); N < B; N++) {
					F[N] = L(F[N], K);
					A(F, N);
					J && (J[N] = L(J[N], _));
					J && A(J, N);
					$(F, J, K, _, N);
					$(J, F, _, K, N);
					var M = F[N], C = J && J[N], D = M[k], G = J && C[k];
					K.x = M[D - 2];
					K.y = M[D - 1];
					K.bx = v0(M[D - 4]) || K.x;
					K.by = v0(M[D - 3]) || K.y;
					_.bx = J && (v0(C[G - 4]) || _.x);
					_.by = J && (v0(C[G - 3]) || _.y);
					_.x = J && C[G - 2];
					_.y = J && C[G - 1]
				}
				return J ? [F, J] : F
			}, null, W0), w = s0(function(D) {
				var C = [];
				for (var F = 0, E = D[k]; F < E; F++) {
					var _ = {}, H = D[F].match(/^([^:]*):?([\d\.]*)/);
					_.color = k0.getRGB(H[1]);
					if (_.color.error)
						return null;
					_.color = _.color.hex;
					H[2] && (_.offset = H[2] + "%");
					C[f](_)
				}
				for (F = 1, E = C[k] - 1; F < E; F++)
					if (!C[F].offset) {
						var $ = v0(C[F - 1].offset || 0), B = 0;
						for (var A = F + 1; A < E; A++)
							if (C[A].offset) {
								B = C[A].offset;
								break
							}
						if (!B) {
							B = 100;
							A = E
						}
						B = v0(B);
						var G = (B - $) / (A - F + 1);
						for (; F < A; F++) {
							$ += G;
							C[F].offset = $ + "%"
						}
					}
				return C
			}), j0 = function(_, B, C, $) {
		var A;
		if (k0.is(_, "string") || k0.is(_, "object")) {
			A = k0.is(_, "string") ? T.getElementById(_) : _;
			if (A.tagName)
				if (B == null)
					return {
						container : A,
						width : A.style.pixelWidth || A.offsetWidth,
						height : A.style.pixelHeight || A.offsetHeight
					};
				else
					return {
						container : A,
						width : B,
						height : C
					}
		} else if (k0.is(_, g0) && $ != null)
			return {
				container : 1,
				x : _,
				y : B,
				width : C,
				height : $
			}
	}, S0 = function(_, B) {
		var A = this;
		for (var $ in B)
			if (B[Q]($) && !($ in _))
				switch (typeof B[$]) {
					case "function" :
						(function(B) {
							_[$] = _ === A ? B : function() {
								return B[c](A, arguments)
							}
						})(B[$]);
						break;
					case "object" :
						_[$] = _[$] || {};
						S0.call(this, _[$], B[$]);
						break;
					default :
						_[$] = B[$];
						break
				}
	}, q0 = function($, _) {
		$ == _.top && (_.top = $.prev);
		$ == _.bottom && (_.bottom = $.next);
		$.next && ($.next.prev = $.prev);
		$.prev && ($.prev.next = $.next)
	}, t0 = function($, _) {
		if (_.top === $)
			return;
		q0($, _);
		$.next = null;
		$.prev = _.top;
		_.top.next = $;
		_.top = $
	}, m = function($, _) {
		if (_.bottom === $)
			return;
		q0($, _);
		$.next = _.bottom;
		$.prev = null;
		_.bottom.prev = $;
		_.bottom = $
	}, $ = function(_, $, A) {
		q0(_, A);
		$ == A.top && (A.top = _);
		$.next && ($.next.prev = _);
		_.next = $.next;
		_.prev = $;
		$.next = _
	}, h0 = function(_, $, A) {
		q0(_, A);
		$ == A.bottom && (A.bottom = _);
		$.prev && ($.prev.next = _);
		_.prev = $.prev;
		$.prev = _;
		_.next = $
	}, t = function($) {
		return function() {
			throw new Error("Rapha\xebl: you are calling to method \u201c" + $
					+ "\u201d of removed object")
		}
	}, b0 = /^r(?:\(([^,]+?)\s*,\s*([^\)]+?)\))?/;
	if (k0.svg) {
		X[O].svgns = "http://www.w3.org/2000/svg";
		X[O].xlink = "http://www.w3.org/1999/xlink";
		N = function($) {
			return +$ + (~~$ === $) * 0.5
		};
		var e = function(B) {
			for (var A = 0, $ = B[k]; A < $; A++)
				if (A0.call(B[A][0]) != "a") {
					for (var _ = 1, C = B[A][k]; _ < C; _++)
						B[A][_] = N(B[A][_])
				} else {
					B[A][6] = N(B[A][6]);
					B[A][7] = N(B[A][7])
				}
			return B
		}, G0 = function(A, $) {
			if ($) {
				for (var _ in $)
					if ($[Q](_))
						A[$0](_, $[_] + T0)
			} else
				return T.createElementNS(X[O].svgns, A)
		};
		k0[M0] = function() {
			return "Your browser supports SVG.\nYou are running Rapha\xebl "
					+ this.version
		};
		var v = function(_, $) {
			var A = G0("path");
			$.canvas && $.canvas[I0](A);
			var B = new Y0(A, $);
			B.type = "path";
			z0(B, {
						fill : "none",
						stroke : "#000",
						path : _
					});
			return B
		}, h = function(G, C, _) {
			var K = "linear", O = 0.5, M = 0.5, H = G.style;
			C = (C + T0)[B0](b0, function(_, B, A) {
						K = "radial";
						if (B && A) {
							O = v0(B);
							M = v0(A);
							var $ = ((M > 0.5) * 2 - 1);
							H0(O - 0.5, 2) + H0(M - 0.5, 2) > 0.25
									&& (M = $1.sqrt(0.25 - H0(O - 0.5, 2)) * $
											+ 0.5) && M != 0.5
									&& (M = M.toFixed(5) - 0.00001 * $)
						}
						return T0
					});
			C = C[E](/\s*\-\s*/);
			if (K == "linear") {
				var N = C.shift();
				N = -v0(N);
				if (isNaN(N))
					return null;
				var F = [0, 0, $1.cos(N * $1.PI / 180), $1.sin(N * $1.PI / 180)], B = 1
						/ (q($1.abs(F[2]), $1.abs(F[3])) || 1);
				F[2] *= B;
				F[3] *= B;
				if (F[2] < 0) {
					F[0] = -F[2];
					F[2] = 0
				}
				if (F[3] < 0) {
					F[1] = -F[3];
					F[3] = 0
				}
			}
			var J = w(C);
			if (!J)
				return null;
			var A = G.getAttribute("fill");
			A = A.match(/^url\(#(.*)\)$/);
			A && _.defs.removeChild(T.getElementById(A[1]));
			var $ = G0(K + "Gradient");
			$.id = "r" + (k0._id++)[M0](36);
			G0($,	K == "radial" ? {
						fx : O,
						fy : M
					} : {
						x1 : F[0],
						y1 : F[1],
						x2 : F[2],
						y2 : F[3]
					});
			_.defs[I0]($);
			for (var I = 0, D = J[k]; I < D; I++) {
				var L = G0("stop");
				G0(L, {
							offset : J[I].offset ? J[I].offset : !I
									? "0%"
									: "100%",
							"stop-color" : J[I].color || "#fff"
						});
				$[I0](L)
			}
			G0(G, {
						fill : "url(#" + $.id + ")",
						opacity : 1,
						"fill-opacity" : 1
					});
			H.fill = T0;
			H.opacity = 1;
			H.fillOpacity = 1;
			return 1
		}, S = function(_) {
			var $ = _.getBBox();
			G0(_.pattern, {
						patternTransform : k0.format("translate({0},{1})", $.x,
								$.y)
					})
		}, z0 = function(Y, C) {
			var O = {
				"" : [0],
				none : [0],
				"-" : [3, 1],
				"." : [1, 1],
				"-." : [3, 1, 1, 1],
				"-.." : [3, 1, 1, 1, 1, 1],
				". " : [1, 3],
				"- " : [4, 3],
				"--" : [8, 3],
				"- ." : [4, 3, 1, 3],
				"--." : [8, 3, 1, 3],
				"--.." : [8, 3, 1, 3, 1, 3]
			}, F = Y.node, J = Y.attrs, V = Y.rotate(), P = function(A, B) {
				B = O[A0.call(B)];
				if (B) {
					var _ = A.attrs["stroke-width"] || "1", E = {
						round : _,
						square : _,
						butt : 0
					}[A.attrs["stroke-linecap"] || C["stroke-linecap"]] || 0, $ = [], D = B[k];
					while (D--)
						$[D] = B[D] * _ + ((D % 2) ? 1 : -1) * E;
					G0(F, {
								"stroke-dasharray" : $[a0](",")
							})
				}
			};
			C[Q]("rotation") && (V = C.rotation);
			var b = (V + T0)[E](j);
			if (!(b.length - 1))
				b = null;
			else {
				b[1] = +b[1];
				b[2] = +b[2]
			}
			v0(V) && Y.rotate(0, true);
			for (var U in C)
				if (C[Q](U)) {
					if (!p[Q](U))
						continue;
					var L = C[U];
					J[U] = L;
					switch (U) {
						case "blur" :
							Y.blur(L);
							break;
						case "rotation" :
							Y.rotate(L, true);
							break;
						case "href" :
						case "title" :
						case "target" :
							var H = F.parentNode;
							if (A0.call(H.tagName) != "a") {
								var $ = G0("a");
								H.insertBefore($, F);
								$[I0](F);
								H = $
							}
							H.setAttributeNS(Y.paper.xlink, U, L);
							break;
						case "cursor" :
							F.style.cursor = L;
							break;
						case "clip-rect" :
							var A = (L + T0)[E](j);
							if (A[k] == 4) {
								Y.clip
										&& Y.clip.parentNode.parentNode
												.removeChild(Y.clip.parentNode);
								var D = G0("clipPath"), G = G0("rect");
								D.id = "r" + (k0._id++)[M0](36);
								G0(G, {
											x : A[0],
											y : A[1],
											width : A[2],
											height : A[3]
										});
								D[I0](G);
								Y.paper.defs[I0](D);
								G0(F, {
											"clip-path" : "url(#" + D.id + ")"
										});
								Y.clip = G
							}
							if (!L) {
								var I = T.getElementById(F
										.getAttribute("clip-path")[B0](
										/(^url\(#|\)$)/g, T0));
								I && I.parentNode.removeChild(I);
								G0(F, {
											"clip-path" : T0
										});
								delete Y.clip
							}
							break;
						case "path" :
							if (Y.type == "path")
								G0(F, {
											d : L ? J.path = e(u(L)) : "M0,0"
										});
							break;
						case "width" :
							F[$0](U, L);
							if (J.fx) {
								U = "x";
								L = J.x
							} else
								break;
						case "x" :
							if (J.fx)
								L = -J.x - (J.width || 0);
						case "rx" :
							if (U == "rx" && Y.type == "rect")
								break;
						case "cx" :
							b && (U == "x" || U == "cx") && (b[1] += L - J[U]);
							F[$0](U, N(L));
							Y.pattern && S(Y);
							break;
						case "height" :
							F[$0](U, L);
							if (J.fy) {
								U = "y";
								L = J.y
							} else
								break;
						case "y" :
							if (J.fy)
								L = -J.y - (J.height || 0);
						case "ry" :
							if (U == "ry" && Y.type == "rect")
								break;
						case "cy" :
							b && (U == "y" || U == "cy") && (b[2] += L - J[U]);
							F[$0](U, N(L));
							Y.pattern && S(Y);
							break;
						case "r" :
							if (Y.type == "rect")
								G0(F, {
											rx : L,
											ry : L
										});
							else
								F[$0](U, L);
							break;
						case "src" :
							if (Y.type == "image")
								F.setAttributeNS(Y.paper.xlink, "href", L);
							break;
						case "stroke-width" :
							F.style.strokeWidth = L;
							F[$0](U, L);
							if (J["stroke-dasharray"])
								P(Y, J["stroke-dasharray"]);
							break;
						case "stroke-dasharray" :
							P(Y, L);
							break;
						case "translation" :
							var Z = (L + T0)[E](j);
							Z[0] = +Z[0] || 0;
							Z[1] = +Z[1] || 0;
							if (b) {
								b[1] += Z[0];
								b[2] += Z[1]
							}
							s.call(Y, Z[0], Z[1]);
							break;
						case "scale" :
							Z = (L + T0)[E](j);
							Y.scale(+Z[0] || 1, +Z[1] || +Z[0] || 1,
									isNaN(v0(Z[2])) ? null : +Z[2],
									isNaN(v0(Z[3])) ? null : +Z[3]);
							break;
						case "fill" :
							var R = (L + T0).match(i);
							if (R) {
								D = G0("pattern");
								var X = G0("image");
								D.id = "r" + (k0._id++)[M0](36);
								G0(D, {
											x : 0,
											y : 0,
											patternUnits : "userSpaceOnUse",
											height : 1,
											width : 1
										});
								G0(X, {
											x : 0,
											y : 0
										});
								X.setAttributeNS(Y.paper.xlink, "href", R[1]);
								D[I0](X);
								var B = T.createElement("img");
								B.style.cssText = "position:absolute;left:-9999em;top-9999em";
								B.onload = function() {
									G0(D, {
												width : this.offsetWidth,
												height : this.offsetHeight
											});
									G0(X, {
												width : this.offsetWidth,
												height : this.offsetHeight
											});
									T.body.removeChild(this);
									Y.paper.safari()
								};
								T.body[I0](B);
								B.src = R[1];
								Y.paper.defs[I0](D);
								F.style.fill = "url(#" + D.id + ")";
								G0(F, {
											fill : "url(#" + D.id + ")"
										});
								Y.pattern = D;
								Y.pattern && S(Y);
								break
							}
							if (!k0.getRGB(L).error) {
								delete C.gradient;
								delete J.gradient;
								!k0.is(J.opacity, "undefined")
										&& k0.is(C.opacity, "undefined")
										&& G0(F, {
													opacity : J.opacity
												});
								!k0.is(J["fill-opacity"], "undefined")
										&& k0
												.is(C["fill-opacity"],
														"undefined") && G0(F, {
													"fill-opacity" : J["fill-opacity"]
												})
							} else if ((({
								circle : 1,
								ellipse : 1
							})[Q](Y.type) || (L + T0).charAt() != "r")
									&& h(F, L, Y.paper)) {
								J.gradient = L;
								J.fill = "none";
								break
							}
						case "stroke" :
							F[$0](U, k0.getRGB(L).hex);
							break;
						case "gradient" :
							(({
								circle : 1,
								ellipse : 1
							})[Q](Y.type) || (L + T0).charAt() != "r")
									&& h(F, L, Y.paper);
							break;
						case "opacity" :
						case "fill-opacity" :
							if (J.gradient) {
								var _ = T
										.getElementById(F.getAttribute("fill")[B0](
												/^url\(#|\)$/g, T0));
								if (_) {
									var a = _.getElementsByTagName("stop");
									a[a[k] - 1][$0]("stop-opacity", L)
								}
								break
							}
						default :
							U == "font-size" && (L = M(L, 10) + "px");
							var W = U[B0](/(\-.)/g, function($) {
										return J0.call($.substring(1))
									});
							F.style[W] = L;
							F[$0](U, L);
							break
					}
				}
			K(Y, C);
			if (b)
				Y.rotate(b.join(e0));
			else
				v0(V) && Y.rotate(V, true)
		}, o = 1.2, K = function(_, C) {
			if (_.type != "text"
					|| !(C[Q]("text") || C[Q]("font") || C[Q]("font-size")
							|| C[Q]("x") || C[Q]("y")))
				return;
			var D = _.attrs, A = _.node, G = A.firstChild ? M(T.defaultView
							.getComputedStyle(A.firstChild, T0)
							.getPropertyValue("font-size"), 10) : 10;
			if (C[Q]("text")) {
				D.text = C.text;
				while (A.firstChild)
					A.removeChild(A.firstChild);
				var $ = (C.text + T0)[E]("\n");
				for (var B = 0, F = $[k]; B < F; B++)
					if ($[B]) {
						var I = G0("tspan");
						B && G0(I, {
									dy : G * o,
									x : D.x
								});
						I[I0](T.createTextNode($[B]));
						A[I0](I)
					}
			} else {
				$ = A.getElementsByTagName("tspan");
				for (B = 0, F = $[k]; B < F; B++)
					B && G0($[B], {
								dy : G * o,
								x : D.x
							})
			}
			G0(A, {
						y : D.y
					});
			var H = _.getBBox(), J = D.y - (H.y + H.height / 2);
			J && isFinite(J) && G0(A, {
						y : D.y + J
					})
		}, Y0 = function(A, _) {
			var $ = 0, B = 0;
			this[0] = A;
			this.id = k0._oid++;
			this.node = A;
			A.raphael = this;
			this.paper = _;
			this.attrs = this.attrs || {};
			this.transformations = [];
			this._ = {
				tx : 0,
				ty : 0,
				rt : {
					deg : 0,
					cx : 0,
					cy : 0
				},
				sx : 1,
				sy : 1
			};
			!_.bottom && (_.bottom = this);
			this.prev = _.top;
			_.top && (_.top.next = this);
			_.top = this;
			this.next = null
		};
		Y0[O].rotate = function(A, _, $) {
			if (this.removed)
				return this;
			if (A == null) {
				if (this._.rt.cx)
					return [this._.rt.deg, this._.rt.cx, this._.rt.cy][a0](e0);
				return this._.rt.deg
			}
			var B = this.getBBox();
			A = (A + T0)[E](j);
			if (A[k] - 1) {
				_ = v0(A[1]);
				$ = v0(A[2])
			}
			A = v0(A[0]);
			if (_ != null)
				this._.rt.deg = A;
			else
				this._.rt.deg += A;
			($ == null) && (_ = null);
			this._.rt.cx = _;
			this._.rt.cy = $;
			_ = _ == null ? B.x + B.width / 2 : _;
			$ = $ == null ? B.y + B.height / 2 : $;
			if (this._.rt.deg) {
				this.transformations[0] = k0.format("rotate({0} {1} {2})",
						this._.rt.deg, _, $);
				this.clip && G0(this.clip, {
							transform : k0.format("rotate({0} {1} {2})",
									-this._.rt.deg, _, $)
						})
			} else {
				this.transformations[0] = T0;
				this.clip && G0(this.clip, {
							transform : T0
						})
			}
			G0(this.node, {
						transform : this.transformations[a0](e0)
					});
			return this
		};
		Y0[O].hide = function() {
			!this.removed && (this.node.style.display = "none");
			return this
		};
		Y0[O].show = function() {
			!this.removed && (this.node.style.display = "");
			return this
		};
		Y0[O].remove = function() {
			if (this.removed)
				return;
			q0(this, this.paper);
			this.node.parentNode.removeChild(this.node);
			for (var $ in this)
				delete this[$];
			this.removed = true
		};
		Y0[O].getBBox = function() {
			if (this.removed)
				return this;
			if (this.type == "path")
				return Y(this.attrs.path);
			if (this.node.style.display == "none") {
				this.show();
				var $ = true
			}
			var D = {};
			try {
				D = this.node.getBBox()
			} catch (A) {
			} finally {
				D = D || {}
			}
			if (this.type == "text") {
				D = {
					x : D.x,
					y : Infinity,
					width : 0,
					height : 0
				};
				for (var _ = 0, B = this.node.getNumberOfChars(); _ < B; _++) {
					var C = this.node.getExtentOfChar(_);
					(C.y < D.y) && (D.y = C.y);
					(C.y + C.height - D.y > D.height)
							&& (D.height = C.y + C.height - D.y);
					(C.x + C.width - D.x > D.width)
							&& (D.width = C.x + C.width - D.x)
				}
			}
			$ && this.hide();
			return D
		};
		Y0[O].attr = function($, E) {
			if (this.removed)
				return this;
			if ($ == null) {
				var B = {};
				for (var C in this.attrs)
					if (this.attrs[Q](C))
						B[C] = this.attrs[C];
				this._.rt.deg && (B.rotation = this.rotate());
				(this._.sx != 1 || this._.sy != 1) && (B.scale = this.scale());
				B.gradient && B.fill == "none" && (B.fill = B.gradient)
						&& delete B.gradient;
				return B
			}
			if (E == null && k0.is($, "string")) {
				if ($ == "translation")
					return s.call(this);
				if ($ == "rotation")
					return this.rotate();
				if ($ == "scale")
					return this.scale();
				if ($ == "fill" && this.attrs.fill == "none"
						&& this.attrs.gradient)
					return this.attrs.gradient;
				return this.attrs[$]
			}
			if (E == null && k0.is($, "array")) {
				var _ = {};
				for (var A = 0, D = $.length; A < D; A++)
					_[$[A]] = this.attr($[A]);
				return _
			}
			if (E != null) {
				var F = {};
				F[$] = E;
				z0(this, F)
			} else if ($ != null && k0.is($, "object"))
				z0(this, $);
			return this
		};
		Y0[O].toFront = function() {
			if (this.removed)
				return this;
			this.node.parentNode[I0](this.node);
			var $ = this.paper;
			$.top != this && t0(this, $);
			return this
		};
		Y0[O].toBack = function() {
			if (this.removed)
				return this;
			if (this.node.parentNode.firstChild != this.node) {
				this.node.parentNode.insertBefore(this.node,
						this.node.parentNode.firstChild);
				m(this, this.paper);
				var $ = this.paper
			}
			return this
		};
		Y0[O].insertAfter = function(_) {
			if (this.removed)
				return this;
			var A = _.node;
			if (A.nextSibling)
				A.parentNode.insertBefore(this.node, A.nextSibling);
			else
				A.parentNode[I0](this.node);
			$(this, _, this.paper);
			return this
		};
		Y0[O].insertBefore = function($) {
			if (this.removed)
				return this;
			var _ = $.node;
			_.parentNode.insertBefore(this.node, _);
			h0(this, $, this.paper);
			return this
		};
		Y0[O].blur = function(A) {
			var _ = this;
			if (+A !== 0) {
				var B = G0("filter"), $ = G0("feGaussianBlur");
				_.attrs.blur = A;
				B.id = "r" + (k0._id++)[M0](36);
				G0($, {
							stdDeviation : +A || 1.5
						});
				B.appendChild($);
				_.paper.defs.appendChild(B);
				_._blur = B;
				G0(_.node, {
							filter : "url(#" + B.id + ")"
						})
			} else {
				if (_._blur) {
					_._blur.parentNode.removeChild(_._blur);
					delete _._blur;
					delete _.attrs.blur
				}
				_.node.removeAttribute("filter")
			}
		};
		var R = function(A, _, B, C) {
			_ = N(_);
			B = N(B);
			var $ = G0("circle");
			A.canvas && A.canvas[I0]($);
			var D = new Y0($, A);
			D.attrs = {
				cx : _,
				cy : B,
				r : C,
				fill : "none",
				stroke : "#000"
			};
			D.type = "circle";
			G0($, D.attrs);
			return D
		}, R0 = function(F, _, E, A, B, D) {
			_ = N(_);
			E = N(E);
			var C = G0("rect");
			F.canvas && F.canvas[I0](C);
			var $ = new Y0(C, F);
			$.attrs = {
				x : _,
				y : E,
				width : A,
				height : B,
				r : D || 0,
				rx : D || 0,
				ry : D || 0,
				fill : "none",
				stroke : "#000"
			};
			$.type = "rect";
			G0(C, $.attrs);
			return $
		}, r0 = function(A, _, D, B, C) {
			_ = N(_);
			D = N(D);
			var $ = G0("ellipse");
			A.canvas && A.canvas[I0]($);
			var E = new Y0($, A);
			E.attrs = {
				cx : _,
				cy : D,
				rx : B,
				ry : C,
				fill : "none",
				stroke : "#000"
			};
			E.type = "ellipse";
			G0($, E.attrs);
			return E
		}, x = function(F, D, _, E, A, B) {
			var C = G0("image");
			G0(C, {
						x : _,
						y : E,
						width : A,
						height : B,
						preserveAspectRatio : "none"
					});
			C.setAttributeNS(F.xlink, "href", D);
			F.canvas && F.canvas[I0](C);
			var $ = new Y0(C, F);
			$.attrs = {
				x : _,
				y : E,
				width : A,
				height : B,
				src : D
			};
			$.type = "image";
			return $
		}, w0 = function(A, _, B, C) {
			var $ = G0("text");
			G0($, {
						x : _,
						y : B,
						"text-anchor" : "middle"
					});
			A.canvas && A.canvas[I0]($);
			var D = new Y0($, A);
			D.attrs = {
				x : _,
				y : B,
				"text-anchor" : "middle",
				text : C,
				font : p.font,
				stroke : "none",
				fill : "#000"
			};
			D.type = "text";
			z0(D, D.attrs);
			return D
		}, b = function(_, $) {
			this.width = _ || this.width;
			this.height = $ || this.height;
			this.canvas[$0]("width", this.width);
			this.canvas[$0]("height", this.height);
			return this
		}, z = function() {
			var $ = j0[c](0, arguments), E = $ && $.container, A = $.x, D = $.y, C = $.width, _ = $.height;
			if (!E)
				throw new Error("SVG container not found.");
			var B = G0("svg");
			C = C || 512;
			_ = _ || 342;
			G0(B, {
						xmlns : "http://www.w3.org/2000/svg",
						version : 1.1,
						width : C,
						height : _
					});
			if (E == 1) {
				B.style.cssText = "position:absolute;left:" + A + "px;top:" + D
						+ "px";
				T.body[I0](B)
			} else if (E.firstChild)
				E.insertBefore(B, E.firstChild);
			else
				E[I0](B);
			E = new X;
			E.width = C;
			E.height = _;
			E.canvas = B;
			S0.call(E, E, k0.fn);
			E.clear();
			return E
		};
		X[O].clear = function() {
			var $ = this.canvas;
			while ($.firstChild)
				$.removeChild($.firstChild);
			this.bottom = this.top = null;
			(this.desc = G0("desc"))[I0](T
					.createTextNode("Created with Rapha\xebl"));
			$[I0](this.desc);
			$[I0](this.defs = G0("defs"))
		};
		X[O].remove = function() {
			this.canvas.parentNode
					&& this.canvas.parentNode.removeChild(this.canvas);
			for (var $ in this)
				this[$] = t($)
		}
	}
	if (k0.vml) {
		var J = {
			M : "m",
			L : "l",
			C : "c",
			Z : "x",
			m : "t",
			l : "r",
			c : "v",
			z : "x"
		}, c0 = /([clmz]),?([^clmz]*)/gi, d0 = /-?[^,\s-]+/g, L0 = 1000 + e0
				+ 1000, y = 10, E0 = function(G) {
			var K = /[ahqstv]/ig, $ = u;
			(G + T0).match(K) && ($ = F);
			K = /[clmz]/g;
			if ($ == u && !(G + T0).match(K)) {
				var I = (G + T0)[B0](c0, function(_, B, C) {
							var A = [], D = A0.call(B) == "m", $ = J[B];
							C[B0](d0, function(_) {
										if (D && A[k] == 2) {
											$ += A + J[B == "m" ? "l" : "L"];
											A = []
										}
										A[f](N(_ * y))
									});
							return $ + A
						});
				return I
			}
			var D = $(G), A, _;
			I = [];
			for (var B = 0, E = D[k]; B < E; B++) {
				A = D[B];
				_ = A0.call(D[B][0]);
				_ == "z" && (_ = "x");
				for (var C = 1, H = A[k]; C < H; C++)
					_ += N(A[C] * y) + (C != H - 1 ? "," : T0);
				I[f](_)
			}
			return I[a0](e0)
		};
		k0[M0] = function() {
			return "Your browser doesn\u2019t support SVG. Falling down to VML.\nYou are running Rapha\xebl "
					+ this.version
		};
		v = function(E, A) {
			var B = m0("group");
			B.style.cssText = "position:absolute;left:0;top:0;width:" + A.width
					+ "px;height:" + A.height + "px";
			B.coordsize = A.coordsize;
			B.coordorigin = A.coordorigin;
			var C = m0("shape"), $ = C.style;
			$.width = A.width + "px";
			$.height = A.height + "px";
			C.coordsize = L0;
			C.coordorigin = A.coordorigin;
			B[I0](C);
			var D = new Y0(C, B, A), _ = {
				fill : "none",
				stroke : "#000"
			};
			E && (_.path = E);
			D.isAbsolute = true;
			D.type = "path";
			D.path = [];
			D.Path = T0;
			z0(D, _);
			A.canvas[I0](B);
			return D
		};
		z0 = function(M, H) {
			M.attrs = M.attrs || {};
			var R = M.node, I = M.attrs, S = R.style, $, F = M;
			for (var U in H)
				if (H[Q](U))
					I[U] = H[U];
			H.href && (R.href = H.href);
			H.title && (R.title = H.title);
			H.target && (R.target = H.target);
			H.cursor && (S.cursor = H.cursor);
			"blur" in H && M.blur(H.blur);
			if (H.path && M.type == "path") {
				I.path = H.path;
				R.path = E0(I.path)
			}
			if (H.rotation != null)
				M.rotate(H.rotation, true);
			if (H.translation) {
				$ = (H.translation + T0)[E](j);
				s.call(M, $[0], $[1]);
				if (M._.rt.cx != null) {
					M._.rt.cx += +$[0];
					M._.rt.cy += +$[1];
					M.setBox(M.attrs, $[0], $[1])
				}
			}
			if (H.scale) {
				$ = (H.scale + T0)[E](j);
				M.scale(+$[0] || 1, +$[1] || +$[0] || 1, +$[2] || null, +$[3]
								|| null)
			}
			if ("clip-rect" in H) {
				var _ = (H["clip-rect"] + T0)[E](j);
				if (_[k] == 4) {
					_[2] = +_[2] + (+_[0]);
					_[3] = +_[3] + (+_[1]);
					var V = R.clipRect || T.createElement("div"), D = V.style, J = R.parentNode;
					D.clip = k0.format("rect({1}px {2}px {3}px {0}px)", _);
					if (!R.clipRect) {
						D.position = "absolute";
						D.top = 0;
						D.left = 0;
						D.width = M.paper.width + "px";
						D.height = M.paper.height + "px";
						J.parentNode.insertBefore(V, J);
						V[I0](J);
						R.clipRect = V
					}
				}
				if (!H["clip-rect"])
					R.clipRect && (R.clipRect.style.clip = T0)
			}
			if (M.type == "image" && H.src)
				R.src = H.src;
			if (M.type == "image" && H.opacity) {
				R.filterOpacity = " progid:DXImageTransform.Microsoft.Alpha(opacity="
						+ (H.opacity * 100) + ")";
				S.filter = (R.filterMatrix || T0) + (R.filterOpacity || T0)
			}
			H.font && (S.font = H.font);
			H["font-family"]
					&& (S.fontFamily = "\""
							+ H["font-family"][E](",")[0][B0](/^['"]+|['"]+$/g,
									T0) + "\"");
			H["font-size"] && (S.fontSize = H["font-size"]);
			H["font-weight"] && (S.fontWeight = H["font-weight"]);
			H["font-style"] && (S.fontStyle = H["font-style"]);
			if (H.opacity != null || H["stroke-width"] != null
					|| H.fill != null || H.stroke != null
					|| H["stroke-width"] != null || H["stroke-opacity"] != null
					|| H["fill-opacity"] != null
					|| H["stroke-dasharray"] != null
					|| H["stroke-miterlimit"] != null
					|| H["stroke-linejoin"] != null
					|| H["stroke-linecap"] != null) {
				R = M.shape || R;
				var G = (R.getElementsByTagName("fill") && R
						.getElementsByTagName("fill")[0]), L = false;
				!G && (L = G = m0("fill"));
				if ("fill-opacity" in H || "opacity" in H) {
					var A = ((+I["fill-opacity"] + 1 || 2) - 1)
							* ((+I.opacity + 1 || 2) - 1);
					A < 0 && (A = 0);
					A > 1 && (A = 1);
					G.opacity = A
				}
				H.fill && (G.on = true);
				if (G.on == null || H.fill == "none")
					G.on = false;
				if (G.on && H.fill) {
					var B = H.fill.match(i);
					if (B) {
						G.src = B[1];
						G.type = "tile"
					} else {
						G.color = k0.getRGB(H.fill).hex;
						G.src = T0;
						G.type = "solid";
						if (k0.getRGB(H.fill).error && (F.type in {
							circle : 1,
							ellipse : 1
						} || (H.fill + T0).charAt() != "r") && h(F, H.fill)) {
							I.fill = "none";
							I.gradient = H.fill
						}
					}
				}
				L && R[I0](G);
				var K = (R.getElementsByTagName("stroke") && R
						.getElementsByTagName("stroke")[0]), C = false;
				!K && (C = K = m0("stroke"));
				if ((H.stroke && H.stroke != "none") || H["stroke-width"]
						|| H["stroke-opacity"] != null || H["stroke-dasharray"]
						|| H["stroke-miterlimit"] || H["stroke-linejoin"]
						|| H["stroke-linecap"])
					K.on = true;
				(H.stroke == "none" || K.on == null || H.stroke == 0 || H["stroke-width"] == 0)
						&& (K.on = false);
				K.on && H.stroke && (K.color = k0.getRGB(H.stroke).hex);
				A = ((+I["stroke-opacity"] + 1 || 2) - 1)
						* ((+I.opacity + 1 || 2) - 1);
				var O = (v0(H["stroke-width"]) || 1) * 0.75;
				A < 0 && (A = 0);
				A > 1 && (A = 1);
				H["stroke-width"] == null && (O = I["stroke-width"]);
				H["stroke-width"] && (K.weight = O);
				O && O < 1 && (A *= O) && (K.weight = 1);
				K.opacity = A;
				H["stroke-linejoin"]
						&& (K.joinstyle = H["stroke-linejoin"] || "miter");
				K.miterlimit = H["stroke-miterlimit"] || 8;
				H["stroke-linecap"]
						&& (K.endcap = H["stroke-linecap"] == "butt"
								? "flat"
								: H["stroke-linecap"] == "square"
										? "square"
										: "round");
				if (H["stroke-dasharray"]) {
					var P = {
						"-" : "shortdash",
						"." : "shortdot",
						"-." : "shortdashdot",
						"-.." : "shortdashdotdot",
						". " : "dot",
						"- " : "dash",
						"--" : "longdash",
						"- ." : "dashdot",
						"--." : "longdashdot",
						"--.." : "longdashdotdot"
					};
					K.dashstyle = P[Q](H["stroke-dasharray"])
							? P[H["stroke-dasharray"]]
							: T0
				}
				C && R[I0](K)
			}
			if (F.type == "text") {
				S = F.paper.span.style;
				I.font && (S.font = I.font);
				I["font-family"] && (S.fontFamily = I["font-family"]);
				I["font-size"] && (S.fontSize = I["font-size"]);
				I["font-weight"] && (S.fontWeight = I["font-weight"]);
				I["font-style"] && (S.fontStyle = I["font-style"]);
				F.node.string
						&& (F.paper.span.innerHTML = (F.node.string + T0)[B0](
								/</g, "&#60;")[B0](/&/g, "&#38;")[B0](/\n/g,
								"<br>"));
				F.W = I.w = F.paper.span.offsetWidth;
				F.H = I.h = F.paper.span.offsetHeight;
				F.X = I.x;
				F.Y = I.y + N(F.H / 2);
				switch (I["text-anchor"]) {
					case "start" :
						F.node.style["v-text-align"] = "left";
						F.bbx = N(F.W / 2);
						break;
					case "end" :
						F.node.style["v-text-align"] = "right";
						F.bbx = -N(F.W / 2);
						break;
					default :
						F.node.style["v-text-align"] = "center";
						break
				}
			}
		};
		h = function(_, I) {
			_.attrs = _.attrs || {};
			var J = _.attrs, F = _.node.getElementsByTagName("fill"), B = "linear", H = ".5 .5";
			_.attrs.gradient = I;
			I = (I + T0)[B0](b0, function(_, $, A) {
						B = "radial";
						if ($ && A) {
							$ = v0($);
							A = v0(A);
							H0($ - 0.5, 2) + H0(A - 0.5, 2) > 0.25
									&& (A = $1.sqrt(0.25 - H0($ - 0.5, 2))
											* ((A > 0.5) * 2 - 1) + 0.5);
							H = $ + e0 + A
						}
						return T0
					});
			I = I[E](/\s*\-\s*/);
			if (B == "linear") {
				var A = I.shift();
				A = -v0(A);
				if (isNaN(A))
					return null
			}
			var C = w(I);
			if (!C)
				return null;
			_ = _.shape || _.node;
			F = F[0] || m0("fill");
			if (C[k]) {
				F.on = true;
				F.method = "none";
				F.type = (B == "radial") ? "gradientradial" : "gradient";
				F.color = C[0].color;
				F.color2 = C[C[k] - 1].color;
				var G = [];
				for (var $ = 0, D = C[k]; $ < D; $++)
					C[$].offset && G[f](C[$].offset + e0 + C[$].color);
				F.colors
						&& (F.colors.value = G[k] ? G[a0](",") : "0% "
								+ F.color);
				if (B == "radial") {
					F.focus = "100%";
					F.focussize = H;
					F.focusposition = H
				} else
					F.angle = (270 - A) % 360
			}
			return 1
		};
		Y0 = function(C, D, _) {
			var B = 0, E = 0, A = 0, $ = 1;
			this[0] = C;
			this.id = k0._oid++;
			this.node = C;
			C.raphael = this;
			this.X = 0;
			this.Y = 0;
			this.attrs = {};
			this.Group = D;
			this.paper = _;
			this._ = {
				tx : 0,
				ty : 0,
				rt : {
					deg : 0
				},
				sx : 1,
				sy : 1
			};
			!_.bottom && (_.bottom = this);
			this.prev = _.top;
			_.top && (_.top.next = this);
			_.top = this;
			this.next = null
		};
		Y0[O].rotate = function(_, $, A) {
			if (this.removed)
				return this;
			if (_ == null) {
				if (this._.rt.cx)
					return [this._.rt.deg, this._.rt.cx, this._.rt.cy][a0](e0);
				return this._.rt.deg
			}
			_ = (_ + T0)[E](j);
			if (_[k] - 1) {
				$ = v0(_[1]);
				A = v0(_[2])
			}
			_ = v0(_[0]);
			if ($ != null)
				this._.rt.deg = _;
			else
				this._.rt.deg += _;
			A == null && ($ = null);
			this._.rt.cx = $;
			this._.rt.cy = A;
			this.setBox(this.attrs, $, A);
			this.Group.style.rotation = this._.rt.deg;
			return this
		};
		Y0[O].setBox = function(C, A, _) {
			if (this.removed)
				return this;
			var O = this.Group.style, I = (this.shape && this.shape.style)
					|| this.node.style;
			C = C || {};
			for (var J in C)
				if (C[Q](J))
					this.attrs[J] = C[J];
			A = A || this._.rt.cx;
			_ = _ || this._.rt.cy;
			var F = this.attrs, R, P, S, B;
			switch (this.type) {
				case "circle" :
					R = F.cx - F.r;
					P = F.cy - F.r;
					S = B = F.r * 2;
					break;
				case "ellipse" :
					R = F.cx - F.rx;
					P = F.cy - F.ry;
					S = F.rx * 2;
					B = F.ry * 2;
					break;
				case "rect" :
				case "image" :
					R = +F.x;
					P = +F.y;
					S = F.width || 0;
					B = F.height || 0;
					break;
				case "text" :
					this.textpath.v = ["m", N(F.x), ", ", N(F.y - 2), "l",
							N(F.x) + 1, ", ", N(F.y - 2)][a0](T0);
					R = F.x - N(this.W / 2);
					P = F.y - this.H / 2;
					S = this.W;
					B = this.H;
					break;
				case "path" :
					if (!this.attrs.path) {
						R = 0;
						P = 0;
						S = this.paper.width;
						B = this.paper.height
					} else {
						var H = Y(this.attrs.path);
						R = H.x;
						P = H.y;
						S = H.width;
						B = H.height
					}
					break;
				default :
					R = 0;
					P = 0;
					S = this.paper.width;
					B = this.paper.height;
					break
			}
			A = (A == null) ? R + S / 2 : A;
			_ = (_ == null) ? P + B / 2 : _;
			var $ = A - this.paper.width / 2, M = _ - this.paper.height / 2, L;
			O.left != (L = $ + "px") && (O.left = L);
			O.top != (L = M + "px") && (O.top = L);
			this.X = this.type == "path" ? -$ : R;
			this.Y = this.type == "path" ? -M : P;
			this.W = S;
			this.H = B;
			if (this.type == "path") {
				I.left != (L = -$ * y + "px") && (I.left = L);
				I.top != (L = -M * y + "px") && (I.top = L)
			} else if (this.type == "text") {
				I.left != (L = -$ + "px") && (I.left = L);
				I.top != (L = -M + "px") && (I.top = L)
			} else {
				O.width != (L = this.paper.width + "px") && (O.width = L);
				O.height != (L = this.paper.height + "px") && (O.height = L);
				I.left != (L = R - $ + "px") && (I.left = L);
				I.top != (L = P - M + "px") && (I.top = L);
				I.width != (L = S + "px") && (I.width = L);
				I.height != (L = B + "px") && (I.height = L);
				var G = (+C.r || 0) / D0(S, B);
				if (this.type == "rect"
						&& this.arcsize.toFixed(4) != G.toFixed(4)
						&& (G || this.arcsize)) {
					var E = m0("roundrect"), D = {}, K = this.events
							&& this.events[k];
					J = 0;
					E.arcsize = G;
					E.raphael = this;
					this.Group[I0](E);
					this.Group.removeChild(this.node);
					this[0] = this.node = E;
					this.arcsize = G;
					for (J in F)
						D[J] = F[J];
					delete D.scale;
					this.attr(D);
					if (this.events)
						for (; J < K; J++)
							this.events[J].unbind = n0(this.node,
									this.events[J].name, this.events[J].f, this)
				}
			}
		};
		Y0[O].hide = function() {
			!this.removed && (this.Group.style.display = "none");
			return this
		};
		Y0[O].show = function() {
			!this.removed && (this.Group.style.display = "block");
			return this
		};
		Y0[O].getBBox = function() {
			if (this.removed)
				return this;
			if (this.type == "path")
				return Y(this.attrs.path);
			return {
				x : this.X + (this.bbx || 0),
				y : this.Y,
				width : this.W,
				height : this.H
			}
		};
		Y0[O].remove = function() {
			if (this.removed)
				return;
			q0(this, this.paper);
			this.node.parentNode.removeChild(this.node);
			this.Group.parentNode.removeChild(this.Group);
			this.shape && this.shape.parentNode.removeChild(this.shape);
			for (var $ in this)
				delete this[$];
			this.removed = true
		};
		Y0[O].attr = function(A, D) {
			if (this.removed)
				return this;
			if (A == null) {
				var C = {};
				for (var $ in this.attrs)
					if (this.attrs[Q]($))
						C[$] = this.attrs[$];
				this._.rt.deg && (C.rotation = this.rotate());
				(this._.sx != 1 || this._.sy != 1) && (C.scale = this.scale());
				C.gradient && C.fill == "none" && (C.fill = C.gradient)
						&& delete C.gradient;
				return C
			}
			if (D == null && k0.is(A, "string")) {
				if (A == "translation")
					return s.call(this);
				if (A == "rotation")
					return this.rotate();
				if (A == "scale")
					return this.scale();
				if (A == "fill" && this.attrs.fill == "none"
						&& this.attrs.gradient)
					return this.attrs.gradient;
				return this.attrs[A]
			}
			if (this.attrs && D == null && k0.is(A, "array")) {
				var B, _ = {};
				for ($ = 0, B = A[k]; $ < B; $++)
					_[A[$]] = this.attr(A[$]);
				return _
			}
			var E;
			if (D != null) {
				E = {};
				E[A] = D
			}
			D == null && k0.is(A, "object") && (E = A);
			if (E) {
				if (E.text && this.type == "text")
					this.node.string = E.text;
				z0(this, E);
				if (E.gradient && (({
					circle : 1,
					ellipse : 1
				})[Q](this.type) || (E.gradient + T0).charAt() != "r"))
					h(this, E.gradient);
				(this.type != "path" || this._.rt.deg)
						&& this.setBox(this.attrs)
			}
			return this
		};
		Y0[O].toFront = function() {
			!this.removed && this.Group.parentNode[I0](this.Group);
			this.paper.top != this && t0(this, this.paper);
			return this
		};
		Y0[O].toBack = function() {
			if (this.removed)
				return this;
			if (this.Group.parentNode.firstChild != this.Group) {
				this.Group.parentNode.insertBefore(this.Group,
						this.Group.parentNode.firstChild);
				m(this, this.paper)
			}
			return this
		};
		Y0[O].insertAfter = function(_) {
			if (this.removed)
				return this;
			if (_.Group.nextSibling)
				_.Group.parentNode
						.insertBefore(this.Group, _.Group.nextSibling);
			else
				_.Group.parentNode[I0](this.Group);
			$(this, _, this.paper);
			return this
		};
		Y0[O].insertBefore = function($) {
			if (this.removed)
				return this;
			$.Group.parentNode.insertBefore(this.Group, $.Group);
			h0(this, $, this.paper);
			return this
		};
		var W = / progid:\S+Blur\([^\)]+\)/g;
		Y0[O].blur = function($) {
			var _ = this.node.style, A = _.filter;
			A = A.replace(W, "");
			if (+$ !== 0) {
				this.attrs.blur = $;
				_.filter = A
						+ " progid:DXImageTransform.Microsoft.Blur(pixelradius="
						+ (+$ || 1.5) + ")";
				_.margin = Raphael.format("-{0}px 0 0 -{0}px", Math.round(+$
								|| 1.5))
			} else {
				_.filter = A;
				_.margin = 0;
				delete this.attrs.blur
			}
		};
		R = function(A, _, E, B) {
			var C = m0("group"), D = m0("oval"), F = D.style;
			C.style.cssText = "position:absolute;left:0;top:0;width:" + A.width
					+ "px;height:" + A.height + "px";
			C.coordsize = L0;
			C.coordorigin = A.coordorigin;
			C[I0](D);
			var $ = new Y0(D, C, A);
			$.type = "circle";
			z0($, {
						stroke : "#000",
						fill : "none"
					});
			$.attrs.cx = _;
			$.attrs.cy = E;
			$.attrs.r = B;
			$.setBox({
						x : _ - B,
						y : E - B,
						width : B * 2,
						height : B * 2
					});
			A.canvas[I0](C);
			return $
		};
		R0 = function(A, F, E, H, $, _) {
			var C = m0("group"), G = m0("roundrect"), D = (+_ || 0)
					/ (D0(H, $));
			C.style.cssText = "position:absolute;left:0;top:0;width:" + A.width
					+ "px;height:" + A.height + "px";
			C.coordsize = L0;
			C.coordorigin = A.coordorigin;
			C[I0](G);
			G.arcsize = D;
			var B = new Y0(G, C, A);
			B.type = "rect";
			z0(B, {
						stroke : "#000"
					});
			B.arcsize = D;
			B.setBox({
						x : F,
						y : E,
						width : H,
						height : $,
						r : _
					});
			A.canvas[I0](C);
			return B
		};
		r0 = function(_, G, E, F, A) {
			var C = m0("group"), $ = m0("oval"), D = $.style;
			C.style.cssText = "position:absolute;left:0;top:0;width:" + _.width
					+ "px;height:" + _.height + "px";
			C.coordsize = L0;
			C.coordorigin = _.coordorigin;
			C[I0]($);
			var B = new Y0($, C, _);
			B.type = "ellipse";
			z0(B, {
						stroke : "#000"
					});
			B.attrs.cx = G;
			B.attrs.cy = E;
			B.attrs.rx = F;
			B.attrs.ry = A;
			B.setBox({
						x : G - F,
						y : E - A,
						width : F * 2,
						height : A * 2
					});
			_.canvas[I0](C);
			return B
		};
		x = function(A, _, H, F, D, $) {
			var C = m0("group"), G = m0("image"), E = G.style;
			C.style.cssText = "position:absolute;left:0;top:0;width:" + A.width
					+ "px;height:" + A.height + "px";
			C.coordsize = L0;
			C.coordorigin = A.coordorigin;
			G.src = _;
			C[I0](G);
			var B = new Y0(G, C, A);
			B.type = "image";
			B.attrs.src = _;
			B.attrs.x = H;
			B.attrs.y = F;
			B.attrs.w = D;
			B.attrs.h = $;
			B.setBox({
						x : H,
						y : F,
						width : D,
						height : $
					});
			A.canvas[I0](C);
			return B
		};
		w0 = function(A, I, G, D) {
			var C = m0("group"), $ = m0("shape"), F = $.style, E = m0("path"), _ = E.style, H = m0("textpath");
			C.style.cssText = "position:absolute;left:0;top:0;width:" + A.width
					+ "px;height:" + A.height + "px";
			C.coordsize = L0;
			C.coordorigin = A.coordorigin;
			E.v = k0.format("m{0},{1}l{2},{1}", N(I * 10), N(G * 10), N(I * 10)
							+ 1);
			E.textpathok = true;
			F.width = A.width;
			F.height = A.height;
			H.string = D + T0;
			H.on = true;
			$[I0](H);
			$[I0](E);
			C[I0]($);
			var B = new Y0(H, C, A);
			B.shape = $;
			B.textpath = E;
			B.type = "text";
			B.attrs.text = D;
			B.attrs.x = I;
			B.attrs.y = G;
			B.attrs.w = 1;
			B.attrs.h = 1;
			z0(B, {
						font : p.font,
						stroke : "none",
						fill : "#000"
					});
			B.setBox();
			A.canvas[I0](C);
			return B
		};
		b = function(A, $) {
			var _ = this.canvas.style;
			A == +A && (A += "px");
			$ == +$ && ($ += "px");
			_.width = A;
			_.height = $;
			_.clip = "rect(0 " + A + " " + $ + " 0)";
			return this
		};
		var m0;
		T.createStyleSheet().addRule(".rvml", "behavior:url(#default#VML)");
		try {
			!T.namespaces.rvml
					&& T.namespaces
							.add("rvml", "urn:schemas-microsoft-com:vml");
			m0 = function($) {
				return T.createElement("<rvml:" + $ + " class=\"rvml\">")
			}
		} catch (o0) {
			m0 = function($) {
				return T
						.createElement("<"
								+ $
								+ " xmlns=\"urn:schemas-microsoft.com:vml\" class=\"rvml\">")
			}
		}
		z = function() {
			var H = j0[c](0, arguments), _ = H.container, G = H.height, D, A = H.width, F = H.x, E = H.y;
			if (!_)
				throw new Error("VML container not found.");
			var C = new X, B = C.canvas = T.createElement("div"), $ = B.style;
			A = A || 512;
			G = G || 342;
			A == +A && (A += "px");
			G == +G && (G += "px");
			C.width = 1000;
			C.height = 1000;
			C.coordsize = y * 1000 + e0 + y * 1000;
			C.coordorigin = "0 0";
			C.span = T.createElement("span");
			C.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;";
			B[I0](C.span);
			$.cssText = k0
					.format(
							"width:{0};height:{1};position:absolute;clip:rect(0 {0} {1} 0);overflow:hidden",
							A, G);
			if (_ == 1) {
				T.body[I0](B);
				$.left = F + "px";
				$.top = E + "px"
			} else {
				_.style.width = A;
				_.style.height = G;
				if (_.firstChild)
					_.insertBefore(B, _.firstChild);
				else
					_[I0](B)
			}
			S0.call(C, C, k0.fn);
			return C
		};
		X[O].clear = function() {
			this.canvas.innerHTML = T0;
			this.span = T.createElement("span");
			this.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;";
			this.canvas[I0](this.span);
			this.bottom = this.top = null
		};
		X[O].remove = function() {
			this.canvas.parentNode.removeChild(this.canvas);
			for (var $ in this)
				this[$] = t($);
			return true
		}
	}
	if ((/^Apple|^Google/).test(U0.navigator.vendor)
			&& !(U0.navigator.userAgent.indexOf("Version/4.0") + 1))
		X[O].safari = function() {
			var $ = this.rect(-99, -99, this.width + 99, this.height + 99);
			U0.setTimeout(function() {
						$.remove()
					})
		};
	else
		X[O].safari = function() {
		};
	var n0 = (function() {
		if (T.addEventListener)
			return function(B, C, A, _) {
				var $ = function($) {
					return A.call(_, $)
				};
				B.addEventListener(C, $, false);
				return function() {
					B.removeEventListener(C, $, false);
					return true
				}
			};
		else if (T.attachEvent)
			return function(B, $, D, A) {
				var C = function($) {
					return D.call(A, $ || U0.event)
				};
				B.attachEvent("on" + $, C);
				var _ = function() {
					B.detachEvent("on" + $, C);
					return true
				};
				return _
			}
	})();
	for (var x0 = L[k]; x0--;)
		(function($) {
			Y0[O][$] = function(_) {
				if (k0.is(_, "function")) {
					this.events = this.events || [];
					this.events.push({
								name : $,
								f : _,
								unbind : n0(this.shape || this.node, $, _, this)
							})
				}
				return this
			};
			Y0[O]["un" + $] = function(_) {
				var B = this.events, A = B[k];
				while (A--)
					if (B[A].name == $ && B[A].f == _) {
						B[A].unbind();
						B.splice(A, 1);
						!B.length && delete this.events;
						return this
					}
				return this
			}
		})(L[x0]);
	Y0[O].hover = function(_, $) {
		return this.mouseover(_).mouseout($)
	};
	Y0[O].unhover = function(_, $) {
		return this.unmouseover(_).unmouseout($)
	};
	X[O].circle = function($, A, _) {
		return R(this, $ || 0, A || 0, _ || 0)
	};
	X[O].rect = function(_, B, A, C, $) {
		return R0(this, _ || 0, B || 0, A || 0, C || 0, $ || 0)
	};
	X[O].ellipse = function(_, $, B, A) {
		return r0(this, _ || 0, $ || 0, B || 0, A || 0)
	};
	X[O].path = function($) {
		$ && !k0.is($, "string") && !k0.is($[0], "array") && ($ += T0);
		return v(k0.format[c](k0, arguments), this)
	};
	X[O].image = function($, _, B, A, C) {
		return x(this, $ || "about:blank", _ || 0, B || 0, A || 0, C || 0)
	};
	X[O].text = function($, A, _) {
		return w0(this, $ || 0, A || 0, _ || T0)
	};
	X[O].set = function($) {
		arguments[k] > 1
				&& ($ = Array[O].splice.call(arguments, 0, arguments[k]));
		return new a($)
	};
	X[O].setSize = b;
	X[O].top = X[O].bottom = null;
	X[O].raphael = k0;
	function _0() {
		return this.x + e0 + this.y
	}
	Y0[O].scale = function(X, W, $, d) {
		if (X == null && W == null)
			return {
				x : this._.sx,
				y : this._.sy,
				toString : _0
			};
		W = W || X;
		!+W && (W = X);
		var S, O, Q, N, D = this.attrs;
		if (X != 0) {
			var U = this.getBBox(), a = U.x + U.width / 2, R = U.y + U.height
					/ 2, E = X / this._.sx, B = W / this._.sy;
			$ = (+$ || $ == 0) ? $ : a;
			d = (+d || d == 0) ? d : R;
			var T = ~~(X / $1.abs(X)), Z = ~~(W / $1.abs(W)), L = this.node.style, A = $
					+ (a - $) * E, _ = d + (R - d) * B;
			switch (this.type) {
				case "rect" :
				case "image" :
					var b = D.width * T * E, K = D.height * Z * B;
					this.attr({
								height : K,
								r : D.r * D0(T * E, Z * B),
								width : b,
								x : A - b / 2,
								y : _ - K / 2
							});
					break;
				case "circle" :
				case "ellipse" :
					this.attr({
								rx : D.rx * T * E,
								ry : D.ry * Z * B,
								r : D.r * D0(T * E, Z * B),
								cx : A,
								cy : _
							});
					break;
				case "path" :
					var G = y0(D.path), F = true;
					for (var H = 0, J = G[k]; H < J; H++) {
						var M = G[H], P = J0.call(M[0]);
						if (P == "M" && F)
							continue;
						else
							F = false;
						if (P == "A") {
							M[G[H][k] - 2] *= E;
							M[G[H][k] - 1] *= B;
							M[1] *= T * E;
							M[2] *= Z * B;
							M[5] = +!(T + Z ? !+M[5] : +M[5])
						} else if (P == "H") {
							for (var I = 1, C = M[k]; I < C; I++)
								M[I] *= E
						} else if (P == "V") {
							for (I = 1, C = M[k]; I < C; I++)
								M[I] *= B
						} else
							for (I = 1, C = M[k]; I < C; I++)
								M[I] *= (I % 2) ? E : B
					}
					var c = Y(G);
					S = A - c.x - c.width / 2;
					O = _ - c.y - c.height / 2;
					G[0][1] += S;
					G[0][2] += O;
					this.attr({
								path : G
							});
					break
			}
			if (this.type in {
				text : 1,
				image : 1
			} && (T != 1 || Z != 1)) {
				if (this.transformations) {
					this.transformations[2] = "scale("[V](T, ",", Z, ")");
					this.node[$0]("transform", this.transformations[a0](e0));
					S = (T == -1) ? -D.x - (b || 0) : D.x;
					O = (Z == -1) ? -D.y - (K || 0) : D.y;
					this.attr({
								x : S,
								y : O
							});
					D.fx = T - 1;
					D.fy = Z - 1
				} else {
					this.node.filterMatrix = " progid:DXImageTransform.Microsoft.Matrix(M11="[V](
							T, ", M12=0, M21=0, M22=", Z,
							", Dx=0, Dy=0, sizingmethod='auto expand', filtertype='bilinear')");
					L.filter = (this.node.filterMatrix || T0)
							+ (this.node.filterOpacity || T0)
				}
			} else if (this.transformations) {
				this.transformations[2] = T0;
				this.node[$0]("transform", this.transformations[a0](e0));
				D.fx = 0;
				D.fy = 0
			} else {
				this.node.filterMatrix = T0;
				L.filter = (this.node.filterMatrix || T0)
						+ (this.node.filterOpacity || T0)
			}
			D.scale = [X, W, $, d][a0](e0);
			this._.sx = X;
			this._.sy = W
		}
		return this
	};
	Y0[O].clone = function() {
		var $ = this.attr();
		delete $.scale;
		delete $.translation;
		return this.paper[this.type]().attr($)
	};
	var g = s0(function($, _, J, I, B, H, G, F, D) {
				var E = 0, C;
				for (var K = 0; K < 1.001; K += 0.001) {
					var A = k0.findDotsAtSegment($, _, J, I, B, H, G, F, K);
					K && (E += H0(H0(C.x - A.x, 2) + H0(C.y - A.y, 2), 0.5));
					if (E >= D)
						return A;
					C = A
				}
			}), N0 = function($, _) {
		return function(D, E, L) {
			D = F(D);
			var J, I, A, M, G = "", C = {}, K, H = 0;
			for (var N = 0, B = D.length; N < B; N++) {
				A = D[N];
				if (A[0] == "M") {
					J = +A[1];
					I = +A[2]
				} else {
					M = l(J, I, A[1], A[2], A[3], A[4], A[5], A[6]);
					if (H + M > E) {
						if (_ && !C.start) {
							K = g(J, I, A[1], A[2], A[3], A[4], A[5], A[6], E
											- H);
							G += ["C", K.start.x, K.start.y, K.m.x, K.m.y, K.x,
									K.y];
							if (L)
								return G;
							C.start = G;
							G = ["M", K.x, K.y + "C", K.n.x, K.n.y, K.end.x,
									K.end.y, A[5], A[6]][a0]();
							H += M;
							J = +A[5];
							I = +A[6];
							continue
						}
						if (!$ && !_) {
							K = g(J, I, A[1], A[2], A[3], A[4], A[5], A[6], E
											- H);
							return {
								x : K.x,
								y : K.y,
								alpha : K.alpha
							}
						}
					}
					H += M;
					J = +A[5];
					I = +A[6]
				}
				G += A
			}
			C.end = G;
			K = $ ? H : _ ? C : k0.findDotsAtSegment(J, I, A[1], A[2], A[3],
					A[4], A[5], A[6], 1);
			K.alpha && (K = {
				x : K.x,
				y : K.y,
				alpha : K.alpha
			});
			return K
		}
	}, l = s0(function($, _, H, B, G, F, E, D) {
				var C = {
					x : 0,
					y : 0
				}, J = 0;
				for (var I = 0; I < 1.01; I += 0.01) {
					var A = P($, _, H, B, G, F, E, D, I);
					I && (J += H0(H0(C.x - A.x, 2) + H0(C.y - A.y, 2), 0.5));
					C = A
				}
				return J
			}), i0 = N0(1), A = N0(), H = N0(0, 1);
	Y0[O].getTotalLength = function() {
		if (this.type != "path")
			return;
		return i0(this.attrs.path)
	};
	Y0[O].getPointAtLength = function($) {
		if (this.type != "path")
			return;
		return A(this.attrs.path, $)
	};
	Y0[O].getSubpath = function(A, _) {
		if (this.type != "path")
			return;
		if ($1.abs(this.getTotalLength() - _) < 0.000001)
			return H(this.attrs.path, A).end;
		var $ = H(this.attrs.path, _, 1);
		return A ? H($, A).end : $
	};
	k0.easing_formulas = {
		linear : function($) {
			return $
		},
		"<" : function($) {
			return H0($, 3)
		},
		">" : function($) {
			return H0($ - 1, 3) + 1
		},
		"<>" : function($) {
			$ = $ * 2;
			if ($ < 1)
				return H0($, 3) / 2;
			$ -= 2;
			return (H0($, 3) + 2) / 2
		},
		backIn : function(_) {
			var $ = 1.70158;
			return _ * _ * (($ + 1) * _ - $)
		},
		backOut : function(_) {
			_ = _ - 1;
			var $ = 1.70158;
			return _ * _ * (($ + 1) * _ + $) + 1
		},
		elastic : function(A) {
			if (A == 0 || A == 1)
				return A;
			var _ = 0.3, $ = _ / 4;
			return H0(2, -10 * A) * $1.sin((A - $) * (2 * $1.PI) / _) + 1
		},
		bounce : function($) {
			var A = 7.5625, B = 2.75, _;
			if ($ < (1 / B))
				_ = A * $ * $;
			else if ($ < (2 / B)) {
				$ -= (1.5 / B);
				_ = A * $ * $ + 0.75
			} else if ($ < (2.5 / B)) {
				$ -= (2.25 / B);
				_ = A * $ * $ + 0.9375
			} else {
				$ -= (2.625 / B);
				_ = A * $ * $ + 0.984375
			}
			return _
		}
	};
	var G = {
		length : 0
	}, U = function() {
		var a = +new Date;
		for (var K in G)
			if (K != "length" && G[Q](K)) {
				var B = G[K];
				if (B.stop || B.el.removed) {
					delete G[K];
					G[k]--;
					continue
				}
				var Y = a - B.start, H = B.ms, R = B.easing, D = B.from, L = B.diff, $ = B.to, X = B.t, O = B.prev
						|| 0, Z = B.el, S = B.callback, M = {}, b;
				if (Y < H) {
					var P = k0.easing_formulas[R]
							? k0.easing_formulas[R](Y / H)
							: Y / H;
					for (var I in D)
						if (D[Q](I)) {
							switch (u0[I]) {
								case "along" :
									b = P * H * L[I];
									$.back && (b = $.len - b);
									var J = A($[I], b);
									Z.translate(L.sx - L.x || 0, L.sy - L.y
													|| 0);
									L.x = J.x;
									L.y = J.y;
									Z.translate(J.x - L.sx, J.y - L.sy);
									$.rot && Z.rotate(L.r + J.alpha, J.x, J.y);
									break;
								case "number" :
									b = +D[I] + P * H * L[I];
									break;
								case "colour" :
									b = "rgb("
											+ [
													_(N(D[I].r + P * H * L[I].r)),
													_(N(D[I].g + P * H * L[I].g)),
													_(N(D[I].b + P * H * L[I].b))][a0](",")
											+ ")";
									break;
								case "path" :
									b = [];
									for (var F = 0, W = D[I][k]; F < W; F++) {
										b[F] = [D[I][F][0]];
										for (var C = 1, E = D[I][F][k]; C < E; C++)
											b[F][C] = +D[I][F][C] + P * H
													* L[I][F][C];
										b[F] = b[F][a0](e0)
									}
									b = b[a0](e0);
									break;
								case "csv" :
									switch (I) {
										case "translation" :
											var V = L[I][0] * (Y - O), T = L[I][1]
													* (Y - O);
											X.x += V;
											X.y += T;
											b = V + e0 + T;
											break;
										case "rotation" :
											b = +D[I][0] + P * H * L[I][0];
											D[I][1]
													&& (b += "," + D[I][1]
															+ "," + D[I][2]);
											break;
										case "scale" :
											b = [+D[I][0] + P * H * L[I][0],
													+D[I][1] + P * H * L[I][1],
													(2 in $[I] ? $[I][2] : T0),
													(3 in $[I] ? $[I][3] : T0)][a0](e0);
											break;
										case "clip-rect" :
											b = [];
											F = 4;
											while (F--)
												b[F] = +D[I][F] + P * H
														* L[I][F];
											break
									}
									break
							}
							M[I] = b
						}
					Z.attr(M);
					Z._run && Z._run.call(Z)
				} else {
					if ($.along) {
						J = A($.along, $.len * !$.back);
						Z.translate(L.sx - (L.x || 0) + J.x - L.sx, L.sy
										- (L.y || 0) + J.y - L.sy);
						$.rot && Z.rotate(L.r + J.alpha, J.x, J.y)
					}
					(X.x || X.y) && Z.translate(-X.x, -X.y);
					$.scale && ($.scale = $.scale + T0);
					Z.attr($);
					delete G[K];
					G[k]--;
					Z.in_animation = null;
					k0.is(S, "function") && S.call(Z)
				}
				B.prev = Y
			}
		k0.svg && Z && Z.paper.safari();
		G[k] && U0.setTimeout(U)
	}, _ = function($) {
		return $ > 255 ? 255 : ($ < 0 ? 0 : $)
	}, s = function($, A) {
		if ($ == null)
			return {
				x : this._.tx,
				y : this._.ty,
				toString : _0
			};
		this._.tx += +$;
		this._.ty += +A;
		switch (this.type) {
			case "circle" :
			case "ellipse" :
				this.attr({
							cx : +$ + this.attrs.cx,
							cy : +A + this.attrs.cy
						});
				break;
			case "rect" :
			case "image" :
			case "text" :
				this.attr({
							x : +$ + this.attrs.x,
							y : +A + this.attrs.y
						});
				break;
			case "path" :
				var _ = y0(this.attrs.path);
				_[0][1] += +$;
				_[0][2] += +A;
				this.attr({
							path : _
						});
				break
		}
		return this
	};
	Y0[O].animateWith = function(A, C, _, B, $) {
		G[A.id] && (C.start = G[A.id].start);
		return this.animate(C, _, B, $)
	};
	Y0[O].animateAlong = Z0();
	Y0[O].animateAlongBack = Z0(1);
	function Z0($) {
		return function(_, D, A, B) {
			var C = {
				back : $
			};
			k0.is(A, "function") ? (B = A) : (C.rot = A);
			_ && _.constructor == Y0 && (_ = _.attrs.path);
			_ && (C.along = _);
			return this.animate(C, D, B)
		}
	}
	Y0[O].onAnimation = function($) {
		this._run = $ || 0;
		return this
	};
	Y0[O].animate = function(I, S, R, $) {
		if (k0.is(R, "function") || !R)
			$ = R || null;
		var M = {}, B = {}, X = {};
		for (var T in I)
			if (I[Q](T))
				if (u0[Q](T)) {
					M[T] = this.attr(T);
					(M[T] == null) && (M[T] = p[T]);
					B[T] = I[T];
					switch (u0[T]) {
						case "along" :
							var D = i0(I[T]), J = A(I[T], D * !!I.back), O = this
									.getBBox();
							X[T] = D / S;
							X.tx = O.x;
							X.ty = O.y;
							X.sx = J.x;
							X.sy = J.y;
							B.rot = I.rot;
							B.back = I.back;
							B.len = D;
							I.rot && (X.r = v0(this.rotate()) || 0);
							break;
						case "number" :
							X[T] = (B[T] - M[T]) / S;
							break;
						case "colour" :
							M[T] = k0.getRGB(M[T]);
							var K = k0.getRGB(B[T]);
							X[T] = {
								r : (K.r - M[T].r) / S,
								g : (K.g - M[T].g) / S,
								b : (K.b - M[T].b) / S
							};
							break;
						case "path" :
							var L = F(M[T], B[T]);
							M[T] = L[0];
							var P = L[1];
							X[T] = [];
							for (var C = 0, W = M[T][k]; C < W; C++) {
								X[T][C] = [0];
								for (var N = 1, H = M[T][C][k]; N < H; N++)
									X[T][C][N] = (P[C][N] - M[T][C][N]) / S
							}
							break;
						case "csv" :
							var _ = (I[T] + T0)[E](j), V = (M[T] + T0)[E](j);
							switch (T) {
								case "translation" :
									M[T] = [0, 0];
									X[T] = [_[0] / S, _[1] / S];
									break;
								case "rotation" :
									M[T] = (V[1] == _[1] && V[2] == _[2])
											? V
											: [0, _[1], _[2]];
									X[T] = [(_[0] - M[T][0]) / S, 0, 0];
									break;
								case "scale" :
									I[T] = _;
									M[T] = (M[T] + T0)[E](j);
									X[T] = [(_[0] - M[T][0]) / S,
											(_[1] - M[T][1]) / S, 0, 0];
									break;
								case "clip-rect" :
									M[T] = (M[T] + T0)[E](j);
									X[T] = [];
									C = 4;
									while (C--)
										X[T][C] = (_[C] - M[T][C]) / S;
									break
							}
							B[T] = _
					}
				}
		this.stop();
		this.in_animation = 1;
		G[this.id] = {
			start : I.start || +new Date,
			ms : S,
			easing : R,
			from : M,
			diff : X,
			to : B,
			el : this,
			callback : $,
			t : {
				x : 0,
				y : 0
			}
		};
		++G[k] == 1 && U();
		return this
	};
	Y0[O].stop = function() {
		G[this.id] && G[k]--;
		delete G[this.id];
		return this
	};
	Y0[O].translate = function($, _) {
		return this.attr({
					translation : $ + " " + _
				})
	};
	Y0[O][M0] = function() {
		return "Rapha\xebl\u2019s object"
	};
	k0.ae = G;
	var a = function(_) {
		this.items = [];
		this[k] = 0;
		if (_)
			for (var A = 0, $ = _[k]; A < $; A++)
				if (_[A] && (_[A].constructor == Y0 || _[A].constructor == a)) {
					this[this.items[k]] = this.items[this.items[k]] = _[A];
					this[k]++
				}
	};
	a[O][f] = function() {
		var B, _;
		for (var A = 0, $ = arguments[k]; A < $; A++) {
			B = arguments[A];
			if (B && (B.constructor == Y0 || B.constructor == a)) {
				_ = this.items[k];
				this[_] = this.items[_] = B;
				this[k]++
			}
		}
		return this
	};
	a[O].pop = function() {
		delete this[this[k]--];
		return this.items.pop()
	};
	for (var C in Y0[O])
		if (Y0[O][Q](C))
			a[O][C] = (function($) {
				return function() {
					for (var A = 0, _ = this.items[k]; A < _; A++)
						this.items[A][$][c](this.items[A], arguments);
					return this
				}
			})(C);
	a[O].attr = function(A, D) {
		if (A && k0.is(A, "array") && k0.is(A[0], "object")) {
			for (var _ = 0, B = A[k]; _ < B; _++)
				this.items[_].attr(A[_])
		} else
			for (var $ = 0, C = this.items[k]; $ < C; $++)
				this.items[$].attr(A, D);
		return this
	};
	a[O].animate = function(B, A, F, E) {
		(k0.is(F, "function") || !F) && (E = F || null);
		var _ = this.items[k], $ = _, D = this, C;
		E && (C = function() {
			!--_ && E.call(D)
		});
		this.items[--$].animate(B, A, F || C, C);
		while ($--)
			this.items[$].animateWith(this.items[_ - 1], B, A, F || C, C);
		return this
	};
	a[O].insertAfter = function(_) {
		var $ = this.items[k];
		while ($--)
			this.items[$].insertAfter(_);
		return this
	};
	a[O].getBBox = function() {
		var _ = [], D = [], A = [], C = [];
		for (var $ = this.items[k]; $--;) {
			var B = this.items[$].getBBox();
			_[f](B.x);
			D[f](B.y);
			A[f](B.x + B.width);
			C[f](B.y + B.height)
		}
		_ = D0[c](0, _);
		D = D0[c](0, D);
		return {
			x : _,
			y : D,
			width : q[c](0, A) - _,
			height : q[c](0, C) - D
		}
	};
	a[O].clone = function($) {
		$ = new a;
		for (var _ = 0, A = this.items[k]; _ < A; _++)
			$[f](this.items[_].clone());
		return $
	};
	k0.registerFont = function(A) {
		if (!A.face)
			return A;
		this.fonts = this.fonts || {};
		var $ = {
			w : A.w,
			face : {},
			glyphs : {}
		}, E = A.face["font-family"];
		for (var D in A.face)
			if (A.face[Q](D))
				$.face[D] = A.face[D];
		if (this.fonts[E])
			this.fonts[E][f]($);
		else
			this.fonts[E] = [$];
		if (!A.svg) {
			$.face["units-per-em"] = M(A.face["units-per-em"], 10);
			for (var C in A.glyphs)
				if (A.glyphs[Q](C)) {
					var B = A.glyphs[C];
					$.glyphs[C] = {
						w : B.w,
						k : {},
						d : B.d && "M" + B.d[B0](/[mlcxtrv]/g, function($) {
									return {
										l : "L",
										c : "C",
										x : "z",
										t : "m",
										r : "l",
										v : "c"
									}[$] || "M"
								}) + "z"
					};
					if (B.k)
						for (var _ in B.k)
							if (B[Q](_))
								$.glyphs[C].k[_] = B.k[_]
				}
		}
		return A
	};
	X[O].getFont = function(H, D, A, C) {
		C = C || "normal";
		A = A || "normal";
		D = +D || {
			normal : 400,
			bold : 700,
			lighter : 300,
			bolder : 800
		}[D] || 400;
		var B = k0.fonts[H];
		if (!B) {
			var $ = new RegExp("(^|\\s)" + H[B0](/[^\w\d\s+!~.:_-]/g, T0)
							+ "(\\s|$)", "i");
			for (var _ in k0.fonts)
				if (k0.fonts[Q](_))
					if ($.test(_)) {
						B = k0.fonts[_];
						break
					}
		}
		var F;
		if (B)
			for (var G = 0, E = B[k]; G < E; G++) {
				F = B[G];
				if (F.face["font-weight"] == D
						&& (F.face["font-style"] == A || !F.face["font-style"])
						&& F.face["font-stretch"] == C)
					break
			}
		return F
	};
	X[O].print = function(I, $, _, P, Q, B) {
		B = B || "middle";
		var D = this.set(), J = (_ + T0)[E](T0), F = 0, L = T0, C;
		k0.is(P, "string") && (P = this.getFont(P));
		if (P) {
			C = (Q || 16) / P.face["units-per-em"];
			var A = P.face.bbox.split(j), O = +A[0], K = +A[1]
					+ (B == "baseline"
							? A[3] - A[1] + (+P.face.descent)
							: (A[3] - A[1]) / 2);
			for (var N = 0, H = J[k]; N < H; N++) {
				var M = N && P.glyphs[J[N - 1]] || {}, G = P.glyphs[J[N]];
				F += N ? (M.w || P.w) + (M.k && M.k[J[N]] || 0) : 0;
				G && G.d && D[f](this.path(G.d).attr({
							fill : "#000",
							stroke : "none",
							translation : [F, 0]
						}))
			}
			D.scale(C, C, O, K).translate(I - O, $ - K)
		}
		return D
	};
	var K0 = /\{(\d+)\}/g;
	k0.format = function(_, A) {
		var $ = k0.is(A, "array") ? [0][V](A) : arguments;
		_ && k0.is(_, "string") && $[k] - 1 && (_ = _[B0](K0, function(A, _) {
					return $[++_] == null ? T0 : $[_]
				}));
		return _ || T0
	};
	k0.ninja = function() {
		n.was ? (Raphael = n.is) : delete Raphael;
		return k0
	};
	k0.el = Y0[O];
	return k0
})();
